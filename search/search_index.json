{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"GivEnergy Modbus \u00b6 A python library to access GivEnergy inverters via Modbus TCP on a local network, with no dependency on the GivEnergy Cloud. This extends pymodbus by providing a custom framer, decoder and PDUs that are specific to the GivEnergy implementation. \u26a0\ufe0f This project makes no representations as to its completeness or correctness. You use it at your own risk \u2014 if your inverter mysteriously explodes because you accidentally set the BOOMTIME register or you consume a MWh of electricity doing SOC calibration: you really are on your own. We make every effort to prevent you from shooting yourself in the foot, so as long as you use the client and its exposed methods, you should be perfectly safe. Documentation: https://dewet22.github.io/givenergy-modbus GitHub: https://github.com/dewet22/givenergy-modbus PyPI: https://pypi.org/project/givenergy-modbus/ Free software: Apache-2.0 Features \u00b6 Reading all registers and decoding them into their representative datatypes Writing data to holding registers that are deemed to be safe to set configuration on the inverter How to use \u00b6 Use the provided client to interact with the device over the network, and register caches to build combined state of a device: import datetime from givenergy_modbus.client import GivEnergyClient from givenergy_modbus.model.battery import Battery from givenergy_modbus.model.inverter import Inverter , Model from givenergy_modbus.model.register_cache import RegisterCache client = GivEnergyClient ( host = \"192.168.99.99\" ) # change configuration on the device: client . enable_charge_target ( 80 ) # set a charging slot from 00:30 to 04:30 client . set_charge_slot_1 (( datetime . time ( hour = 0 , minute = 30 ), datetime . time ( hour = 4 , minute = 30 ))) # set the inverter to charge when there's excess, and discharge otherwise. it will also respect charging slots. client . set_mode_dynamic () rc = RegisterCache () client . update_inverter_registers ( rc ) inverter = Inverter . from_orm ( rc ) assert inverter . inverter_serial_number == 'SA1234G567' assert inverter . inverter_model == Model . Hybrid assert inverter . v_pv1 == 1.4 # V assert inverter . e_battery_discharge_day == 8.1 # kWh assert inverter . enable_charge_target assert inverter . dict () == { 'inverter_serial_number' : 'SA1234G567' , 'device_type_code' : '3001' , 'charge_slot_1' : ( datetime . time ( 0 , 30 ), datetime . time ( 7 , 30 )), 'f_ac1' : 49.98 , ... } assert inverter . json () == '{\"inverter_serial_number\": \"SA1234G567\", \"device_type_code\": \"3001\", ...' # it is _probably_ a good idea to not share register caches across devices rc = RegisterCache () client . update_battery_registers ( rc , battery_number = 0 ) battery = Battery . from_orm ( rc ) assert battery . serial_number == 'BG1234G567' assert battery . v_battery_cell_01 == 3.117 assert battery . dict () == { 'bms_firmware_version' : 3005 , 'design_capacity' : 160.0 , ... } assert battery . json () == '{\"battery_serial_number\": \"BG1234G567\", \"v_battery_cell_01\": 3.117, ...' Credits \u00b6 This package was created with Cookiecutter and the waynerv/cookiecutter-pypackage project template.","title":"Home"},{"location":"#givenergy-modbus","text":"A python library to access GivEnergy inverters via Modbus TCP on a local network, with no dependency on the GivEnergy Cloud. This extends pymodbus by providing a custom framer, decoder and PDUs that are specific to the GivEnergy implementation. \u26a0\ufe0f This project makes no representations as to its completeness or correctness. You use it at your own risk \u2014 if your inverter mysteriously explodes because you accidentally set the BOOMTIME register or you consume a MWh of electricity doing SOC calibration: you really are on your own. We make every effort to prevent you from shooting yourself in the foot, so as long as you use the client and its exposed methods, you should be perfectly safe. Documentation: https://dewet22.github.io/givenergy-modbus GitHub: https://github.com/dewet22/givenergy-modbus PyPI: https://pypi.org/project/givenergy-modbus/ Free software: Apache-2.0","title":"GivEnergy Modbus"},{"location":"#features","text":"Reading all registers and decoding them into their representative datatypes Writing data to holding registers that are deemed to be safe to set configuration on the inverter","title":"Features"},{"location":"#how-to-use","text":"Use the provided client to interact with the device over the network, and register caches to build combined state of a device: import datetime from givenergy_modbus.client import GivEnergyClient from givenergy_modbus.model.battery import Battery from givenergy_modbus.model.inverter import Inverter , Model from givenergy_modbus.model.register_cache import RegisterCache client = GivEnergyClient ( host = \"192.168.99.99\" ) # change configuration on the device: client . enable_charge_target ( 80 ) # set a charging slot from 00:30 to 04:30 client . set_charge_slot_1 (( datetime . time ( hour = 0 , minute = 30 ), datetime . time ( hour = 4 , minute = 30 ))) # set the inverter to charge when there's excess, and discharge otherwise. it will also respect charging slots. client . set_mode_dynamic () rc = RegisterCache () client . update_inverter_registers ( rc ) inverter = Inverter . from_orm ( rc ) assert inverter . inverter_serial_number == 'SA1234G567' assert inverter . inverter_model == Model . Hybrid assert inverter . v_pv1 == 1.4 # V assert inverter . e_battery_discharge_day == 8.1 # kWh assert inverter . enable_charge_target assert inverter . dict () == { 'inverter_serial_number' : 'SA1234G567' , 'device_type_code' : '3001' , 'charge_slot_1' : ( datetime . time ( 0 , 30 ), datetime . time ( 7 , 30 )), 'f_ac1' : 49.98 , ... } assert inverter . json () == '{\"inverter_serial_number\": \"SA1234G567\", \"device_type_code\": \"3001\", ...' # it is _probably_ a good idea to not share register caches across devices rc = RegisterCache () client . update_battery_registers ( rc , battery_number = 0 ) battery = Battery . from_orm ( rc ) assert battery . serial_number == 'BG1234G567' assert battery . v_battery_cell_01 == 3.117 assert battery . dict () == { 'bms_firmware_version' : 3005 , 'design_capacity' : 160.0 , ... } assert battery . json () == '{\"battery_serial_number\": \"BG1234G567\", \"v_battery_cell_01\": 3.117, ...'","title":"How to use"},{"location":"#credits","text":"This package was created with Cookiecutter and the waynerv/cookiecutter-pypackage project template.","title":"Credits"},{"location":"api/","text":"Top-level package for GivEnergy Modbus. cli \u00b6 Console script for interacting with GivEnergy inverters. is_documented_by ( original ) \u00b6 Copies the docstring from the original source to the decorated target. Source code in givenergy_modbus/cli.py def is_documented_by ( original ): \"\"\"Copies the docstring from the original source to the decorated target.\"\"\" def wrapper ( target ): target . __doc__ = original . __doc__ return target return wrapper client \u00b6 GivEnergyClient \u00b6 Client for end users to conveniently access GivEnergy inverters. disable_charge ( self ) \u00b6 Disable the battery from charging. Source code in givenergy_modbus/client.py def disable_charge ( self ): \"\"\"Disable the battery from charging.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . ENABLE_CHARGE , False ) disable_charge_target ( self ) \u00b6 Removes SOC limit and target 100% charging. Source code in givenergy_modbus/client.py def disable_charge_target ( self ): \"\"\"Removes SOC limit and target 100% charging.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . ENABLE_CHARGE_TARGET , False ) self . modbus_client . write_holding_register ( HoldingRegister . CHARGE_TARGET_SOC , 100 ) disable_discharge ( self ) \u00b6 Set the battery to not discharge at all. Source code in givenergy_modbus/client.py def disable_discharge ( self ): \"\"\"Set the battery to not discharge at all.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . ENABLE_DISCHARGE , False ) enable_charge ( self ) \u00b6 Set the battery to charge, depending on the mode and slots set. Source code in givenergy_modbus/client.py def enable_charge ( self ): \"\"\"Set the battery to charge, depending on the mode and slots set.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . ENABLE_CHARGE , True ) enable_charge_target ( self , target_soc ) \u00b6 Sets inverter to stop charging when SOC reaches the desired level. Also referred to as \"winter mode\". Source code in givenergy_modbus/client.py def enable_charge_target ( self , target_soc : int ): \"\"\"Sets inverter to stop charging when SOC reaches the desired level. Also referred to as \"winter mode\".\"\"\" if not 4 <= target_soc <= 100 : raise ValueError ( f 'Specified Charge Target SOC ( { target_soc } ) is not in [4-100]' ) if target_soc == 100 : self . disable_charge_target () else : self . modbus_client . write_holding_register ( HoldingRegister . ENABLE_CHARGE_TARGET , True ) self . modbus_client . write_holding_register ( HoldingRegister . CHARGE_TARGET_SOC , target_soc ) enable_discharge ( self ) \u00b6 Set the battery to discharge, depending on the mode and slots set. Source code in givenergy_modbus/client.py def enable_discharge ( self ): \"\"\"Set the battery to discharge, depending on the mode and slots set.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . ENABLE_DISCHARGE , True ) fetch_register_pages ( self , pages , register_cache , slave_address = 50 , sleep_between_queries = 0.5 ) \u00b6 Reload all inverter data from the device. Source code in givenergy_modbus/client.py def fetch_register_pages ( self , pages : Mapping [ type [ HoldingRegister | InputRegister ], Sequence [ int ]], register_cache : RegisterCache , slave_address : int = 0x32 , sleep_between_queries : float = DEFAULT_SLEEP , ) -> None : \"\"\"Reload all inverter data from the device.\"\"\" for register , base_registers in pages . items (): for base_register in base_registers : data = self . modbus_client . read_registers ( register , base_register , 60 , slave_address = slave_address ) register_cache . set_registers ( register , data ) t . sleep ( sleep_between_queries ) reset_charge_slot_1 ( self ) \u00b6 Reset first charge slot times to zero/disabled. Source code in givenergy_modbus/client.py def reset_charge_slot_1 ( self ): \"\"\"Reset first charge slot times to zero/disabled.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . CHARGE_SLOT_1_START , 0 ) self . modbus_client . write_holding_register ( HoldingRegister . CHARGE_SLOT_1_END , 0 ) reset_charge_slot_2 ( self ) \u00b6 Reset second charge slot times to zero/disabled. Source code in givenergy_modbus/client.py def reset_charge_slot_2 ( self ): \"\"\"Reset second charge slot times to zero/disabled.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . CHARGE_SLOT_2_START , 0 ) self . modbus_client . write_holding_register ( HoldingRegister . CHARGE_SLOT_2_END , 0 ) reset_discharge_slot_1 ( self ) \u00b6 Reset first discharge slot times to zero/disabled. Source code in givenergy_modbus/client.py def reset_discharge_slot_1 ( self ): \"\"\"Reset first discharge slot times to zero/disabled.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . DISCHARGE_SLOT_1_START , 0 ) self . modbus_client . write_holding_register ( HoldingRegister . DISCHARGE_SLOT_1_END , 0 ) reset_discharge_slot_2 ( self ) \u00b6 Reset first discharge slot times to zero/disabled. Source code in givenergy_modbus/client.py def reset_discharge_slot_2 ( self ): \"\"\"Reset first discharge slot times to zero/disabled.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . DISCHARGE_SLOT_2_START , 0 ) self . modbus_client . write_holding_register ( HoldingRegister . DISCHARGE_SLOT_2_END , 0 ) set_battery_charge_limit ( self , val ) \u00b6 Set the battery charge limit. Source code in givenergy_modbus/client.py def set_battery_charge_limit ( self , val : int ): \"\"\"Set the battery charge limit.\"\"\" # TODO what are valid values? if not 0 <= val <= 50 : raise ValueError ( f 'Specified Charge Limit ( { val } %) is not in [0-50]%' ) self . modbus_client . write_holding_register ( HoldingRegister . BATTERY_CHARGE_LIMIT , val ) set_battery_discharge_limit ( self , val ) \u00b6 Set the battery discharge limit. Source code in givenergy_modbus/client.py def set_battery_discharge_limit ( self , val : int ): \"\"\"Set the battery discharge limit.\"\"\" if not 0 <= val <= 50 : raise ValueError ( f 'Specified Discharge Limit ( { val } %) is not in [0-50]%' ) self . modbus_client . write_holding_register ( HoldingRegister . BATTERY_DISCHARGE_LIMIT , val ) set_battery_discharge_mode_demand ( self ) \u00b6 Set the battery to discharge to match demand (no export) when discharging. Source code in givenergy_modbus/client.py def set_battery_discharge_mode_demand ( self ): \"\"\"Set the battery to discharge to match demand (no export) when discharging.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . BATTERY_POWER_MODE , 1 ) set_battery_discharge_mode_max_power ( self ) \u00b6 Set the battery to discharge at maximum power (export) when discharging. Source code in givenergy_modbus/client.py def set_battery_discharge_mode_max_power ( self ): \"\"\"Set the battery to discharge at maximum power (export) when discharging.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . BATTERY_POWER_MODE , 0 ) set_battery_power_reserve ( self , val ) \u00b6 Set the battery power reserve to maintain. Source code in givenergy_modbus/client.py def set_battery_power_reserve ( self , val : int ): \"\"\"Set the battery power reserve to maintain.\"\"\" # TODO what are valid values? self . modbus_client . write_holding_register ( HoldingRegister . BATTERY_DISCHARGE_MIN_POWER_RESERVE , val ) set_battery_target_soc ( self , val ) \u00b6 Set the target SOC when the battery charges. Source code in givenergy_modbus/client.py def set_battery_target_soc ( self , val : int ): \"\"\"Set the target SOC when the battery charges.\"\"\" # TODO what are valid values? self . modbus_client . write_holding_register ( HoldingRegister . CHARGE_TARGET_SOC , val ) set_charge_slot_1 ( self , times ) \u00b6 Set first charge slot times. Source code in givenergy_modbus/client.py def set_charge_slot_1 ( self , times : tuple [ time , time ]): \"\"\"Set first charge slot times.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . CHARGE_SLOT_1_START , int ( times [ 0 ] . strftime ( '%H%M' ))) self . modbus_client . write_holding_register ( HoldingRegister . CHARGE_SLOT_1_END , int ( times [ 1 ] . strftime ( '%H%M' ))) set_charge_slot_2 ( self , times ) \u00b6 Set second charge slot times. Source code in givenergy_modbus/client.py def set_charge_slot_2 ( self , times : tuple [ time , time ]): \"\"\"Set second charge slot times.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . CHARGE_SLOT_2_START , int ( times [ 0 ] . strftime ( '%H%M' ))) self . modbus_client . write_holding_register ( HoldingRegister . CHARGE_SLOT_2_END , int ( times [ 1 ] . strftime ( '%H%M' ))) set_datetime ( self , dt ) \u00b6 Set the date & time of the inverter. Source code in givenergy_modbus/client.py def set_datetime ( self , dt : datetime ): \"\"\"Set the date & time of the inverter.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . SYSTEM_TIME_YEAR , dt . year ) self . modbus_client . write_holding_register ( HoldingRegister . SYSTEM_TIME_MONTH , dt . month ) self . modbus_client . write_holding_register ( HoldingRegister . SYSTEM_TIME_DAY , dt . day ) self . modbus_client . write_holding_register ( HoldingRegister . SYSTEM_TIME_HOUR , dt . hour ) self . modbus_client . write_holding_register ( HoldingRegister . SYSTEM_TIME_MINUTE , dt . minute ) self . modbus_client . write_holding_register ( HoldingRegister . SYSTEM_TIME_SECOND , dt . second ) set_discharge_enable ( self , mode ) \u00b6 Set the battery to discharge. Source code in givenergy_modbus/client.py def set_discharge_enable ( self , mode : bool ): \"\"\"Set the battery to discharge.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . ENABLE_DISCHARGE , int ( mode )) set_discharge_slot_1 ( self , times ) \u00b6 Set first discharge slot times. Source code in givenergy_modbus/client.py def set_discharge_slot_1 ( self , times : tuple [ time , time ]): \"\"\"Set first discharge slot times.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . DISCHARGE_SLOT_1_START , int ( times [ 0 ] . strftime ( '%H%M' )) ) self . modbus_client . write_holding_register ( HoldingRegister . DISCHARGE_SLOT_1_END , int ( times [ 1 ] . strftime ( '%H%M' ))) set_discharge_slot_2 ( self , times ) \u00b6 Set second discharge slot times. Source code in givenergy_modbus/client.py def set_discharge_slot_2 ( self , times : tuple [ time , time ]): \"\"\"Set second discharge slot times.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . DISCHARGE_SLOT_2_START , int ( times [ 0 ] . strftime ( '%H%M' )) ) self . modbus_client . write_holding_register ( HoldingRegister . DISCHARGE_SLOT_2_END , int ( times [ 1 ] . strftime ( '%H%M' ))) set_mode_dynamic ( self ) \u00b6 Set system to Dynamic / Eco mode. This mode is designed to maximise use of solar generation. The battery will charge when there is excess power being generated from your solar panels. The battery will store and hold this energy until your demand increases. The system will try and balance the use of solar and battery so that you are importing and exporting as little energy as possible. This mode is useful if you want to maximise self-consumption of renewable generation and minimise the amount of energy drawn from the grid. Source code in givenergy_modbus/client.py def set_mode_dynamic ( self ): \"\"\"Set system to Dynamic / Eco mode. This mode is designed to maximise use of solar generation. The battery will charge when there is excess power being generated from your solar panels. The battery will store and hold this energy until your demand increases. The system will try and balance the use of solar and battery so that you are importing and exporting as little energy as possible. This mode is useful if you want to maximise self-consumption of renewable generation and minimise the amount of energy drawn from the grid. \"\"\" self . set_battery_discharge_mode_demand () # r27=1 self . set_shallow_charge ( 4 ) # r110=4 self . disable_discharge () # r59=0 set_mode_storage ( self , slot_1 = ( datetime . time ( 16 , 0 ), datetime . time ( 7 , 0 )), slot_2 = None , export = False ) \u00b6 Set system to storage mode with specific discharge slots(s). This mode stores excess solar generation during the day and holds that energy ready for use later in the day. By default, the battery will start to discharge from 4pm-7am to cover energy demand during typical peak hours. This mode is particularly useful if you get charged more for your electricity at certain times to utilise the battery when it is most effective. If the second time slot isn't specified, it will be cleared. You can optionally also choose to export excess energy: instead of discharging to meet only your home demand, the battery will discharge at full power and any excess will be exported to the grid. This is useful if you have a variable export tariff (e.g. Agile export) and you want to target the peak times of day (e.g. 4pm-7pm) when it is both most expensive to import and most valuable to export energy. Source code in givenergy_modbus/client.py def set_mode_storage ( self , slot_1 : tuple [ time , time ] = ( time ( hour = 16 ), time ( hour = 7 )), slot_2 : tuple [ time , time ] = None , export = False ): \"\"\"Set system to storage mode with specific discharge slots(s). This mode stores excess solar generation during the day and holds that energy ready for use later in the day. By default, the battery will start to discharge from 4pm-7am to cover energy demand during typical peak hours. This mode is particularly useful if you get charged more for your electricity at certain times to utilise the battery when it is most effective. If the second time slot isn't specified, it will be cleared. You can optionally also choose to export excess energy: instead of discharging to meet only your home demand, the battery will discharge at full power and any excess will be exported to the grid. This is useful if you have a variable export tariff (e.g. Agile export) and you want to target the peak times of day (e.g. 4pm-7pm) when it is both most expensive to import and most valuable to export energy. \"\"\" if export : self . set_battery_discharge_mode_max_power () # r27=0 else : self . set_battery_discharge_mode_demand () # r27=1 self . set_shallow_charge ( 100 ) # r110=100 self . enable_discharge () # r59=1 self . set_discharge_slot_1 ( slot_1 ) # r56=1600, r57=700 if slot_2 : self . set_discharge_slot_1 ( slot_2 ) # r56=1600, r57=700 else : self . reset_discharge_slot_2 () set_shallow_charge ( self , val ) \u00b6 Set the minimum level of charge to keep. Source code in givenergy_modbus/client.py def set_shallow_charge ( self , val : int ): \"\"\"Set the minimum level of charge to keep.\"\"\" # TODO what are valid values? 4-100? self . modbus_client . write_holding_register ( HoldingRegister . BATTERY_SOC_RESERVE , val ) update_battery_registers ( self , register_cache , sleep_between_queries = 0.5 , battery_number = 0 ) \u00b6 Reload all battery data from a given device. Source code in givenergy_modbus/client.py def update_battery_registers ( self , register_cache : RegisterCache , sleep_between_queries = DEFAULT_SLEEP , battery_number = 0 ) -> None : \"\"\"Reload all battery data from a given device.\"\"\" self . fetch_register_pages ( BATTERY_REGISTER_PAGES , register_cache , slave_address = 0x32 + battery_number , sleep_between_queries = sleep_between_queries , ) update_inverter_registers ( self , register_cache , sleep_between_queries = 0.5 ) \u00b6 Reload inverter data and return an Inverter DTO. Source code in givenergy_modbus/client.py def update_inverter_registers ( self , register_cache : RegisterCache , sleep_between_queries = DEFAULT_SLEEP ) -> None : \"\"\"Reload inverter data and return an Inverter DTO.\"\"\" self . fetch_register_pages ( INVERTER_REGISTER_PAGES , register_cache , slave_address = 0x32 , sleep_between_queries = sleep_between_queries ) decoder \u00b6 GivEnergyDecoder \u00b6 GivEnergy Modbus Decoder factory base class. This is to enable efficient decoding of unencapsulated messages (i.e. having the Modbus-specific framing stripped) and creating populated matching PDU DTO instances. Two factories are created, dealing with messages traveling in a particular direction (Request/Client vs. Response/Server) since implementations generally know what side of the conversation they'll be on. It does allow for more general ideas like being able to decode arbitrary streams of messages (i.e. captured from a network interface) where these classes may be intermixed. The Decoder's job is to do the bare minimum inspecting of the raw message to determine its type, instantiate a concrete PDU handler to decode it, and pass it on. decode ( self , data ) \u00b6 Create an appropriately populated PDU message object from a valid Modbus message. Extracts the function code from the raw message and looks up the matching ModbusPDU handler class that claims that function. This handler is instantiated and passed the raw message, which then proceeds to decode its attributes from the bytestream. Source code in givenergy_modbus/decoder.py def decode ( self , data : bytes ) -> ModbusPDU | ErrorResponse | None : \"\"\"Create an appropriately populated PDU message object from a valid Modbus message. Extracts the `function code` from the raw message and looks up the matching ModbusPDU handler class that claims that function. This handler is instantiated and passed the raw message, which then proceeds to decode its attributes from the bytestream. \"\"\" main_fn = data [ 0 ] data = data [ 1 :] if main_fn == 0x1 : # heartbeat / error? err_response = ErrorResponse () _logger . debug ( f \"About to decode data [ { hexlify ( data ) } ]\" ) err_response . decode ( data ) return err_response elif main_fn == 0x2 : # most functions if len ( data ) <= 19 : _logger . error ( f \"PDU data is too short to find a valid function id: len= { len ( data ) } [ { hexlify ( data ) } ]\" ) return None fn_code = data [ 19 ] response = self . lookupPduClass ( fn_code ) if response : _logger . debug ( f \"About to decode data [ { hexlify ( data ) } ]\" ) r = response ( function_code = fn_code ) r . decode ( data ) return r _logger . error ( f \"No decoder for function code { fn_code } \" ) return None _logger . error ( f \"Unknown main function code { hex ( main_fn ) } \" ) # return ExceptionResponse(main_fn, ModbusExceptions.IllegalFunction) return None lookupPduClass ( self , fn_code ) \u00b6 Attempts to find the ModbusPDU handler class that can handle a given function code. Source code in givenergy_modbus/decoder.py def lookupPduClass ( self , fn_code : int ) -> type [ ModbusPDU ] | None : \"\"\"Attempts to find the ModbusPDU handler class that can handle a given function code.\"\"\" if fn_code >= 0x80 : fn_code &= 0x7F if fn_code in self . _lookup : fn = self . _lookup [ fn_code ] _logger . debug ( f \"Identified incoming PDU as { fn_code } / { friendly_class_name ( fn ) } \" ) return fn return None GivEnergyRequestDecoder \u00b6 Factory class to decode GivEnergy Request PDU messages. Typically used by servers processing inbound requests. GivEnergyResponseDecoder \u00b6 Factory class to decode GivEnergy Response PDU messages. Typically used by clients to process responses. framer \u00b6 GivEnergyModbusFramer \u00b6 GivEnergy Modbus Frame controller. A framer abstracts away all the detail about how marshall the wire protocol, e.g. to detect if a current message frame exists, decoding it, sending it, etc. This implementation understands the idiosyncrasies of GivEnergy's implementation of the Modbus spec. Note that the understanding below comes from observing the wire format and analysing the data interchanges \u2013 no GivEnergy proprietary knowledge was needed or referred to. Packet exchange looks very similar to normal Modbus TCP on the wire, with each message still having a regular 7-byte MBAP header consisting of: tid , the transaction id pid , the protocol id len , the byte count / length of the remaining data following the header uid , the unit id for addressing devices on the Modbus network This is followed by fid / a function code to specify how the message should be decoded into a PDU: [_________MBAP Header______] [_fid_] [_______________data________________] [_tid_][_pid_][_len_][_uid_] 2b 2b 2b 1b 1b (len-1)b GivEnergy's implementation quicks can be summarised as: tid is always 0x5959/'YY' , so the assumption/interpretation is that clients have to poll continually instead of maintaining long-lived connections and using varying tid s to pair requests with responses pid is always 0x0001 , whereas normal Modbus uses 0x0000 len adds 1 extra byte (anecdotally for the unit id?) which normal Modbus does not. This leads to continual off-by-one differences appearing whenever header/frame length calculations are done. This is probably the biggest reason Modbus libraries struggle working out of the box. unit_id is always 0x01 fid is always 0x02/Read Discrete Inputs even for requests that modify registers. The actual intended function is encoded 19 bytes into the data block. You can interpret this as functionally somewhat akin to Modbus sub-functions where we always use the 0x02 main function. Because these fields are static and we have to reinterpret what len means it is simpler to just reconsider the entire header: [___\"MBAP+\" Header____] [_______________GivEnergy Frame_______________] [___h1___][_len_][_h2_] 4b 2b 2b (len+2)b h1 is always 0x59590001 , so can be used as a sanity check during decoding len needs 2 added during calculations because of the previous extra byte off-by-one inconsistency, plus expanding the header by including 1-byte fid h2 is always 0x0102 , so can be used as a sanity check during decoding TODO These constant headers being present would allow for us to scan through the bytestream to try and recover from stream errors and help reset the framing. The GivEnergy frame itself has a consistent format: [____serial____] [___pad___] [_addr_] [_func_] [______data______] [_crc_] 10b 8b 1b 1b Nb 2b serial of the responding data adapter (wifi/GPRS?/ethernet?) plugged into the inverter. For requests this is simply hardcoded as a dummy AB1234G567 pad 's function is unknown - it appears to be a single zero-padded byte that varies across responses, so might be some kind of check/crc? addr is the \"slave\" address, conventionally 0x32 func is the actual function to be executed: 0x3 - read holding registers 0x4 - read input registers 0x6 - write single register data is specific to the invoked function crc - for requests it is calculated using the function id, base register and step count, but it is not clear how those for responses are calculated (or should be checked) In short, the message unframing algorithm is simply: while len ( buffer ) > 8 : tid , pid , len , uid , fid = struct . unpack ( \">HHHBB\" , buffer ) data = buffer [ 8 : 6 + len ] process_message ( tid , pid , len , uid , fid , data ) buffer = buffer [ 6 + len :] # skip buffer over frame Exceptions: Type Description InvalidMessageReceivedException When unable to decode an incoming message. ModbusIOException When the identified function decoder fails to decode a message. addToFrame ( self , message ) \u00b6 Add incoming data to the processing buffer. Source code in givenergy_modbus/framer.py def addToFrame ( self , message : bytes ) -> None : \"\"\"Add incoming data to the processing buffer.\"\"\" self . _buffer += message advanceFrame ( self ) \u00b6 Pop the front-most frame from the buffer. Source code in givenergy_modbus/framer.py def advanceFrame ( self ): \"\"\"Pop the front-most frame from the buffer.\"\"\" length = self . _hsize + self . _length - 2 _logger . debug ( f 'length { length } = { self . _hsize } + { self . _length } - 2, len(buffer) = { len ( self . _buffer ) } ' ) self . _buffer = self . _buffer [ length :] _logger . debug ( f \"buffer is now { len ( self . _buffer ) } bytes: { self . _buffer } \" ) self . _length = 0 buildPacket ( self , message ) \u00b6 Creates a finalised GivEnergy Modbus packet from a constant header plus the encoded PDU. Source code in givenergy_modbus/framer.py def buildPacket ( self , message : ModbusPDU ) -> bytes : \"\"\"Creates a finalised GivEnergy Modbus packet from a constant header plus the encoded PDU.\"\"\" return struct . pack ( self . FRAME_HEAD , 0x5959 , 0x0001 , len ( message . encode ()) + 2 , 0x01 , 0x02 ) + message . encode () checkFrame ( self ) \u00b6 Check and decode the next frame. Returns operation success. Source code in givenergy_modbus/framer.py def checkFrame ( self ) -> bool : \"\"\"Check and decode the next frame. Returns operation success.\"\"\" if self . isFrameReady (): _logger . debug ( 'Frame header should be ready' ) header = self . decode_data () if not header : _logger . debug ( 'Frame header is corrupt, resetting frame' ) # self.resetFrame() return False self . _fcode = header [ \"fcode\" ] self . _length = header [ \"length\" ] # this short a message should not be possible? if self . _length < 2 : _logger . warning ( f \"unexpected short message length { self . _length } , advancing frame\" ) self . advanceFrame () return False # we have at least a complete message, continue if len ( self . _buffer ) >= self . _hsize + self . _length - 2 : return True _logger . debug ( f 'Incomplete message: len(buffer)= { len ( self . _buffer ) } < hsize= { self . _hsize } + length= { self . _length } - 2' ) # we don't have enough of a message yet, try again later _logger . debug ( 'Frame is not complete yet, needs more buffer data' ) return False decode_data ( self , data = None ) \u00b6 Tries to extract the MBAP frame header and performs a few sanity checks. Source code in givenergy_modbus/framer.py def decode_data ( self , data : bytes = None ) -> dict | None : \"\"\"Tries to extract the MBAP frame header and performs a few sanity checks.\"\"\" if not data : data = self . _buffer [: self . _hsize ] if self . isFrameReady (): _logger . debug ( f \"extracting MBAP header from [ { hexlify ( data ) } ] as { self . FRAME_HEAD } \" ) tid , pid , len_ , uid , fid = struct . unpack ( self . FRAME_HEAD , data ) header = dict ( transaction = tid , protocol = pid , length = len_ , unit = uid , fcode = fid ) _logger . debug ( f \"extracted values: { dict (( k , f '0x { v : 02x } ' ) for k , v in header . items ()) } \" ) if tid != 0x5959 or pid != 0x1 or uid != 0x1 : # or fid != 0x2: _logger . debug ( f \"Invalid MBAP header; corruption likely so cowardly refusing to proceed with this frame. \" f \"(0x { tid : 04x } 0x { pid : 04x } 0x { uid : 02x } != 0x5959 0x0001 0x01)\" ) return None return header return None getFrame ( self ) \u00b6 Extract the next PDU frame from the buffer, discarding the leading MBAP header. Source code in givenergy_modbus/framer.py def getFrame ( self ): \"\"\"Extract the next PDU frame from the buffer, discarding the leading MBAP header.\"\"\" return self . _buffer [ self . _hsize - 1 : self . _hsize + self . _length ] getRawFrame ( self ) \u00b6 Returns the complete buffer. Source code in givenergy_modbus/framer.py def getRawFrame ( self ): \"\"\"Returns the complete buffer.\"\"\" return self . _buffer isFrameReady ( self ) \u00b6 Check if we have enough data in the buffer to read at least a frame header. Source code in givenergy_modbus/framer.py def isFrameReady ( self ): \"\"\"Check if we have enough data in the buffer to read at least a frame header.\"\"\" return len ( self . _buffer ) >= self . _hsize populateResult ( self , result ) \u00b6 Populates the Modbus PDU object's metadata attributes from the decoded MBAP headers. Source code in givenergy_modbus/framer.py def populateResult ( self , result : ModbusPDU ): \"\"\"Populates the Modbus PDU object's metadata attributes from the decoded MBAP headers.\"\"\" # no-op, there's nothing interesting in there processIncomingPacket ( self , data , callback , * args , ** kwargs ) \u00b6 Process an incoming packet. This takes in a bytestream from the underlying transport and adds it to the frame buffer. It then repeatedly attempts to perform framing on the buffer by checking for a viable message at the head of the buffer, and if found pops off the expected length of the raw frame for processing. Returns when the buffer is too short to contain any more viable messages. This handles cases where multiple and/or partial messages arrive due to fragmentation or buffering on the underlying transport - these partial messages will try to be completed eventually as more data subsequently arrives and gets handled here. If decoding and processing succeeds for a message, the instantiated PDU DTO is handed to the supplied callback function for onward processing and dispatching. Parameters: Name Type Description Default data bytes Data from underlying transport. required callback Callable Processor to receive newly-decoded PDUs. required Source code in givenergy_modbus/framer.py def processIncomingPacket ( self , data : bytes , callback : Callable , * args , ** kwargs ) -> None : \"\"\"Process an incoming packet. This takes in a bytestream from the underlying transport and adds it to the frame buffer. It then repeatedly attempts to perform framing on the buffer by checking for a viable message at the head of the buffer, and if found pops off the expected length of the raw frame for processing. Returns when the buffer is too short to contain any more viable messages. This handles cases where multiple and/or partial messages arrive due to fragmentation or buffering on the underlying transport - these partial messages will try to be completed eventually as more data subsequently arrives and gets handled here. If decoding and processing succeeds for a message, the instantiated PDU DTO is handed to the supplied callback function for onward processing and dispatching. Args: data: Data from underlying transport. callback: Processor to receive newly-decoded PDUs. \"\"\" _logger . debug ( f 'Incoming { len ( data ) } bytes: { hexlify_packets ( data ) } ' ) self . addToFrame ( data ) while True : if not self . isFrameReady (): _logger . debug ( 'No more frames waiting, exiting' ) break if not self . checkFrame (): _logger . debug ( \"Frame check failed, dropping and resetting!!\" ) self . resetFrame () else : _logger . debug ( 'Hand off to _process' ) self . _process ( callback ) resetFrame ( self ) \u00b6 Reset the entire message buffer. Source code in givenergy_modbus/framer.py def resetFrame ( self ): \"\"\"Reset the entire message buffer.\"\"\" # try to mitigate corruption: if we can find the start of another MBAP header truncate the buffer # only up to that point header_offset = self . _buffer . find ( b ' \\x59\\x59\\x00\\x01 ' , 1 ) if header_offset > 0 : _logger . info ( f 'Found another MBAP header at offset { header_offset } in buffer { hexlify ( self . _buffer ) } , ' 'attempting recovery.' ) self . _buffer = self . _buffer [ header_offset :] else : self . _buffer = b \"\" self . _length = 0 modbus \u00b6 GivEnergyModbusTcpClient \u00b6 GivEnergy Modbus Client implementation. This class ties together all the pieces to create a functional client that can converse with a GivEnergy Modbus implementation over TCP. It exists as a thin wrapper around the ModbusTcpClient to hot patch in our own Framer and TransactionManager since they are hardcoded classes for Decoder and TransactionManager throughout constructors up the call chain. We also provide a few convenience methods to read and write registers. execute ( self , request = None ) \u00b6 Send the given PDU to the remote device and return any PDU returned in response. Source code in givenergy_modbus/modbus.py def execute ( self , request : ModbusPDU = None ) -> ModbusPDU | None : \"\"\"Send the given PDU to the remote device and return any PDU returned in response.\"\"\" _logger . debug ( f 'Sending request { request } ' ) try : response = super () . execute ( request ) if isinstance ( response , ModbusIOException ): _logger . exception ( response ) return response except ModbusIOException as e : _logger . exception ( e ) self . close () return None except Exception as e : # This seems to help with inverters becoming unresponsive from the portal.\"\"\" _logger . exception ( e ) self . close () return None read_holding_registers ( self , address , count = 1 , ** kwargs ) \u00b6 Convenience method to help read out holding registers. Source code in givenergy_modbus/modbus.py def read_holding_registers ( self , address , count = 1 , ** kwargs ) -> dict [ int , int ]: \"\"\"Convenience method to help read out holding registers.\"\"\" return self . read_registers ( HoldingRegister , address , count , ** kwargs ) read_input_registers ( self , address , count = 1 , ** kwargs ) \u00b6 Convenience method to help read out input registers. Source code in givenergy_modbus/modbus.py def read_input_registers ( self , address , count = 1 , ** kwargs ) -> dict [ int , int ]: \"\"\"Convenience method to help read out input registers.\"\"\" return self . read_registers ( InputRegister , address , count , ** kwargs ) read_registers ( self , kind , base_address , register_count , ** kwargs ) \u00b6 Read out registers from the correct location depending on type specified. Source code in givenergy_modbus/modbus.py def read_registers ( self , kind : type [ HoldingRegister | InputRegister ], base_address : int , register_count : int , ** kwargs ) -> dict [ int , int ]: \"\"\"Read out registers from the correct location depending on type specified.\"\"\" # match types of register to their request/response types t_req , t_res = { HoldingRegister : ( ReadHoldingRegistersRequest , ReadHoldingRegistersResponse ), InputRegister : ( ReadInputRegistersRequest , ReadInputRegistersResponse ), }[ kind ] request = t_req ( base_register = base_address , register_count = register_count , ** kwargs ) _logger . debug ( f 'Attempting to read { t_req } s # { request . base_register } -' f ' { request . base_register + request . register_count } from device { hex ( request . slave_address ) } ...' ) response = self . execute ( request ) if response and isinstance ( response , t_res ): if response . base_register != base_address : _logger . error ( f 'Returned base register ( { response . base_register } ) ' f 'does not match that from request ( { base_address } ).' ) return {} if response . register_count != register_count : _logger . error ( f 'Returned register count ( { response . register_count } ) ' f 'does not match that from request ( { register_count } ).' ) return {} return response . to_dict () _logger . error ( f 'Did not receive expected response type: { t_res . __name__ } != { response . __class__ . __name__ } ' ) # FIXME this contract needs improving return {} write_holding_register ( self , register , value ) \u00b6 Write a value to a single holding register. Source code in givenergy_modbus/modbus.py def write_holding_register ( self , register : HoldingRegister , value : int ) -> None : \"\"\"Write a value to a single holding register.\"\"\" if not register . write_safe : # type: ignore # shut up mypy raise ValueError ( f 'Register { register . name } is not safe to write to' ) if value != value & 0xFFFF : raise ValueError ( f 'Value { value } must fit in 2 bytes' ) _logger . info ( f 'Attempting to write { value } / { hex ( value ) } to Holding Register { register . value } / { register . name } ' ) request = WriteHoldingRegisterRequest ( register = register . value , value = value ) result = self . execute ( request ) if isinstance ( result , WriteHoldingRegisterResponse ): if result . value != value : raise AssertionError ( f 'Register read-back value 0x { result . value : 04x } != written value 0x { value : 04x } ' ) else : raise AssertionError ( f 'Unexpected response from remote end: { result } ' ) model special \u00b6 Data model. GivEnergyBaseModel pydantic-model \u00b6 Structured format for all other attributes. Config \u00b6 getter_dict \u00b6 GetterDict implementation to consolidate register data structures. get ( self , key , default = None ) \u00b6 Getter that computes some virtual attributes. Source code in givenergy_modbus/model/__init__.py def get ( self , key : Any , default : Any = None ) -> Any : \"\"\"Getter that computes some virtual attributes.\"\"\" if key == \"inverter_serial_number\" : return '' . join ( [ self . get ( 'inverter_serial_number_1_2' ), self . get ( 'inverter_serial_number_3_4' ), self . get ( 'inverter_serial_number_5_6' ), self . get ( 'inverter_serial_number_7_8' ), self . get ( 'inverter_serial_number_9_10' ), ] ) if key in [ \"num_mppt\" , 'num_phases' ]: obj = self . get ( 'num_mppt_and_num_phases' ) if obj == default : return default elif key == \"num_mppt\" : return obj [ 0 ] return obj [ 1 ] if key == \"battery_serial_number\" : return '' . join ( [ self . get ( 'battery_serial_number_1_2' ), self . get ( 'battery_serial_number_3_4' ), self . get ( 'battery_serial_number_5_6' ), self . get ( 'battery_serial_number_7_8' ), self . get ( 'battery_serial_number_9_10' ), ] ) if key == \"first_battery_serial_number\" : return '' . join ( [ self . get ( 'first_battery_serial_number_1_2' ), self . get ( 'first_battery_serial_number_3_4' ), self . get ( 'first_battery_serial_number_5_6' ), self . get ( 'first_battery_serial_number_7_8' ), self . get ( 'first_battery_serial_number_9_10' ), ] ) # Some special cases first if key == \"system_time\" : return datetime ( self . get ( 'system_time_year' ) + 2000 , self . get ( 'system_time_month' ), self . get ( 'system_time_day' ), self . get ( 'system_time_hour' ), self . get ( 'system_time_minute' ), self . get ( 'system_time_second' ), ) if key in ( 'charge_slot_1' , 'charge_slot_2' , 'discharge_slot_1' , 'discharge_slot_2' ): return self . get ( f ' { key } _start' ), self . get ( f ' { key } _end' ) if key == \"inverter_firmware_version\" : return f 'D0. { self . get ( \"dsp_firmware_version\" ) } -A0. { self . get ( \"arm_firmware_version\" ) } ' # if key == 'modbus_version': # return f'{self.get(\"modbus_version\"):0.2f}' return getattr ( self . _obj , key , default ) battery \u00b6 Battery pydantic-model \u00b6 Structured format for all inverter attributes. inverter \u00b6 Inverter pydantic-model \u00b6 Structured format for all inverter attributes. compute_firmware_version ( values ) classmethod \u00b6 Virtual method to inject a firmware version similar to what the dashboard shows. Source code in givenergy_modbus/model/inverter.py @root_validator def compute_firmware_version ( cls , values ) -> dict : \"\"\"Virtual method to inject a firmware version similar to what the dashboard shows.\"\"\" values [ 'firmware_version' ] = f 'D0. { values [ \"dsp_firmware_version\" ] } -A0. { values [ \"arm_firmware_version\" ] } ' return values compute_model ( values ) classmethod \u00b6 Computes the inverter model from the serial number prefix. Source code in givenergy_modbus/model/inverter.py @root_validator def compute_model ( cls , values ) -> dict : \"\"\"Computes the inverter model from the serial number prefix.\"\"\" values [ 'inverter_model' ] = Model ( values [ 'inverter_serial_number' ][: 2 ]) return values Model \u00b6 Known models of inverters. plant \u00b6 Plant pydantic-model \u00b6 Representation of a complete GivEnergy plant. register \u00b6 HoldingRegister \u00b6 Holding Register definitions. InputRegister \u00b6 Definitions of what registers in the Input Bank represent. Register \u00b6 Mixin to help easier access to register bank structures. Scaling \u00b6 What scaling factor needs to be applied to a register's value. Specified as a divisor instead, because python deals with rounding precision better that way. Type \u00b6 Type of data register represents. Encoding is always big-endian. Unit \u00b6 Measurement unit for the register value. register_cache \u00b6 RegisterCache \u00b6 Holds a cache of Registers populated after querying a device. __getattr__ ( self , item ) special \u00b6 Magic attributes that try to look up and convert register values. Source code in givenergy_modbus/model/register_cache.py def __getattr__ ( self , item : str ): \"\"\"Magic attributes that try to look up and convert register values.\"\"\" item_upper = item . upper () if item_upper in self . _register_lookup_table : register = self . _register_lookup_table [ item_upper ] val = self . _registers [ register ] return register . convert ( val ) elif item_upper + '_H' in self . _register_lookup_table and item_upper + '_L' in self . _register_lookup_table : register_h = self . _register_lookup_table [ item_upper + '_H' ] register_l = self . _register_lookup_table [ item_upper + '_L' ] val_h = self . _registers [ register_h ] << 16 val_l = self . _registers [ register_l ] return register_l . convert ( val_h + val_l ) raise KeyError ( item ) debug ( self ) \u00b6 Dump the internal state of registers and their value representations. Source code in givenergy_modbus/model/register_cache.py def debug ( self ): \"\"\"Dump the internal state of registers and their value representations.\"\"\" class_name = '' for r , v in self . _registers . items (): if class_name != r . __class__ . __name__ : class_name = r . __class__ . __name__ print ( '### ' + class_name + ' ' + '#' * 100 ) print ( f ' { r } { r . name : >35 } : { r . repr ( v ) : 20 } | ' f ' { r . type . name : 15 } { r . scaling . name : 5 } 0x { v : 04x } { v : 10 } ' ) from_json ( data ) classmethod \u00b6 Instantiate a RegisterCache from its JSON form. Source code in givenergy_modbus/model/register_cache.py @classmethod def from_json ( cls , data : str ) -> RegisterCache : \"\"\"Instantiate a RegisterCache from its JSON form.\"\"\" def register_object_hook ( object_dict : dict [ str , int ]) -> dict [ Register , int ]: \"\"\"Rewrite the parsed object to have Register instances as keys instead of their (string) repr.\"\"\" lookup = { 'HR' : HoldingRegister , 'IR' : InputRegister } ret = {} for k , v in object_dict . items (): reg , idx = k . split ( ':' , maxsplit = 1 ) ret [ lookup [ reg ]( int ( idx ))] = v return ret return cls ( registers = json . loads ( data , object_hook = register_object_hook )) set_registers ( self , type_ , registers ) \u00b6 Update internal holding register cache with given values. Source code in givenergy_modbus/model/register_cache.py def set_registers ( self , type_ : type [ Register ], registers : dict [ int , int ]): \"\"\"Update internal holding register cache with given values.\"\"\" for k , v in registers . items (): self . _registers [ type_ ( k )] = v to_json ( self ) \u00b6 Return JSON representation of the register cache, suitable for using with from_json() . Source code in givenergy_modbus/model/register_cache.py def to_json ( self ) -> str : \"\"\"Return JSON representation of the register cache, suitable for using with `from_json()`.\"\"\" return json . dumps ( self . _registers ) register_getter \u00b6 RegisterGetter \u00b6 GetterDict implementation to consolidate register data structures. get ( self , key , default = None ) \u00b6 Getter that computes some virtual attributes. Source code in givenergy_modbus/model/register_getter.py def get ( self , key : Any , default : Any = None ) -> Any : \"\"\"Getter that computes some virtual attributes.\"\"\" if key == \"inverter_serial_number\" : return '' . join ( [ self . get ( 'inverter_serial_number_1_2' ), self . get ( 'inverter_serial_number_3_4' ), self . get ( 'inverter_serial_number_5_6' ), self . get ( 'inverter_serial_number_7_8' ), self . get ( 'inverter_serial_number_9_10' ), ] ) if key in [ \"num_mppt\" , 'num_phases' ]: obj = self . get ( 'num_mppt_and_num_phases' ) if obj == default : return default elif key == \"num_mppt\" : return obj [ 0 ] return obj [ 1 ] if key == \"battery_serial_number\" : return '' . join ( [ self . get ( 'battery_serial_number_1_2' ), self . get ( 'battery_serial_number_3_4' ), self . get ( 'battery_serial_number_5_6' ), self . get ( 'battery_serial_number_7_8' ), self . get ( 'battery_serial_number_9_10' ), ] ) if key == \"first_battery_serial_number\" : return '' . join ( [ self . get ( 'first_battery_serial_number_1_2' ), self . get ( 'first_battery_serial_number_3_4' ), self . get ( 'first_battery_serial_number_5_6' ), self . get ( 'first_battery_serial_number_7_8' ), self . get ( 'first_battery_serial_number_9_10' ), ] ) # Some special cases first if key == \"system_time\" : return datetime ( self . get ( 'system_time_year' ) + 2000 , self . get ( 'system_time_month' ), self . get ( 'system_time_day' ), self . get ( 'system_time_hour' ), self . get ( 'system_time_minute' ), self . get ( 'system_time_second' ), ) if key in ( 'charge_slot_1' , 'charge_slot_2' , 'discharge_slot_1' , 'discharge_slot_2' ): return self . get ( f ' { key } _start' ), self . get ( f ' { key } _end' ) if key == \"inverter_firmware_version\" : return f 'D0. { self . get ( \"dsp_firmware_version\" ) } -A0. { self . get ( \"arm_firmware_version\" ) } ' # if key == 'modbus_version': # return f'{self.get(\"modbus_version\"):0.2f}' return getattr ( self . _obj , key , default ) pdu \u00b6 pymodbus.pdu.ModbusPDU implementations for GivEnergy-specific PDU messages. ErrorResponse \u00b6 Special case PDU that gets returned under some error conditions. decode ( self , data ) \u00b6 Decode response PDU message and populate instance attributes. Source code in givenergy_modbus/pdu.py def decode ( self , data : bytes ): \"\"\"Decode response PDU message and populate instance attributes.\"\"\" decoder = BinaryPayloadDecoder ( data , byteorder = Endian . Big ) self . data_adapter_serial_number = decoder . decode_string ( 10 ) . decode ( \"ascii\" ) self . error_code = decoder . decode_8bit_uint () _logger . debug ( f \"Successfully decoded { len ( data ) } bytes\" ) encode ( self ) \u00b6 Encode request PDU message and populate instance attributes. Source code in givenergy_modbus/pdu.py def encode ( self ) -> bytes : \"\"\"Encode request PDU message and populate instance attributes.\"\"\" self . builder = BinaryPayloadBuilder ( byteorder = Endian . Big ) self . builder . add_string ( f \" { self . data_adapter_serial_number [ - 10 :] : *>10 } \" ) # ensure exactly 10 bytes self . builder . add_8bit_uint ( self . error_code ) return self . builder . to_string () get_response_pdu_size () staticmethod \u00b6 Predict the size of the response PDU. Source code in givenergy_modbus/pdu.py @staticmethod def get_response_pdu_size () -> int : \"\"\"Predict the size of the response PDU.\"\"\" return 11 ModbusPDU \u00b6 Base of the PDU handler tree. Defines the most common shared attributes and code. decode ( self , data ) \u00b6 Decode PDU message and populate instance attributes. Source code in givenergy_modbus/pdu.py def decode ( self , data : bytes ) -> None : \"\"\"Decode PDU message and populate instance attributes.\"\"\" decoder = BinaryPayloadDecoder ( data , byteorder = Endian . Big ) self . data_adapter_serial_number = decoder . decode_string ( 10 ) . decode ( \"ascii\" ) self . padding = decoder . decode_64bit_uint () self . slave_address = decoder . decode_8bit_uint () function_code = decoder . decode_8bit_uint () if function_code >= 0x80 : self . error = True function_code = function_code & 0x7F if self . function_code != function_code : e = ValueError ( f \"Expected function code 0x { self . function_code : 02x } , found 0x { function_code : 02x } instead.\" , self ) _logger . exception ( e ) raise e self . _decode_function_data ( decoder ) self . _ensure_valid_state () _logger . debug ( f \"Successfully decoded { len ( data ) } bytes\" ) encode ( self ) \u00b6 Encode PDU message from instance attributes. Source code in givenergy_modbus/pdu.py def encode ( self ) -> bytes : \"\"\"Encode PDU message from instance attributes.\"\"\" self . _ensure_valid_state () self . builder = BinaryPayloadBuilder ( byteorder = Endian . Big ) self . builder . add_string ( f \" { self . data_adapter_serial_number [ - 10 :] : *>10 } \" ) # ensure exactly 10 bytes self . builder . add_64bit_uint ( self . padding ) self . builder . add_8bit_uint ( self . slave_address ) self . builder . add_8bit_uint ( self . function_code ) self . _encode_function_data () self . _update_check_code () return self . builder . to_string () execute ( self , context ) \u00b6 Called to create the Response PDU after an incoming message has been completely processed. Source code in givenergy_modbus/pdu.py def execute ( self , context : IModbusSlaveContext ) -> ModbusPDU : \"\"\"Called to create the Response PDU after an incoming message has been completely processed.\"\"\" raise NotImplementedError () get_response_pdu_size ( self ) \u00b6 Allows the framer to decapsulate the PDU properly from the MBAP frame header. Source code in givenergy_modbus/pdu.py def get_response_pdu_size ( self ) -> int : \"\"\"Allows the framer to decapsulate the PDU properly from the MBAP frame header.\"\"\" # 20 = 10 (data adapter serial) + 8 (padding) + 1 (slave addr) + 1 (function code) size = 20 + self . _calculate_function_data_size () _logger . debug ( f \"Calculated { size } bytes total response PDU size for { self } \" ) if size >= 247 : _logger . error ( 'Expected response size {size} b exceeds Modbus protocol spec' ) return size ModbusRequest \u00b6 Root of the hierarchy for Request PDUs. execute ( self , context ) \u00b6 Hook that allows a Response PDU to be created from the same context where the Request was handled. Parameters: Name Type Description Default context IModbusSlaveContext A datastore context that should be able to provide the values to populate the Response with. required Source code in givenergy_modbus/pdu.py def execute ( self , context : IModbusSlaveContext ) -> ModbusResponse : \"\"\"Hook that allows a Response PDU to be created from the same context where the Request was handled. Args: context: A datastore context that should be able to provide the values to populate the Response with. \"\"\" # if not (1 <= self.register_count <= 0x7D0): # return self.doException(ModbusExceptions.IllegalValue) # if not context.validate(self.function_code, self.base_register, self.register_count): # return self.doException(ModbusExceptions.IllegalAddress) # values = context.getValues(self.function_code, self.address, self.count) # return ReadRegistersResponse(values) # echo back some values from the Request in the Response raise NotImplementedError () ModbusResponse \u00b6 Root of the hierarchy for Response PDUs. execute ( self , context ) \u00b6 There is no automatic Reply following the processing of a Response. Source code in givenergy_modbus/pdu.py def execute ( self , context ) -> ModbusPDU : \"\"\"There is no automatic Reply following the processing of a Response.\"\"\" ReadHoldingRegistersMeta \u00b6 Request & Response PDUs for function #3/Read Holding Registers. ReadHoldingRegistersRequest \u00b6 Concrete PDU implementation for handling function #3/Read Holding Registers request messages. execute ( self , context ) \u00b6 FIXME if we ever implement a server. Source code in givenergy_modbus/pdu.py def execute ( self , context ) -> ModbusResponse : \"\"\"FIXME if we ever implement a server.\"\"\" raise NotImplementedError () ReadHoldingRegistersResponse \u00b6 Concrete PDU implementation for handling function #3/Read Holding Registers response messages. ReadInputRegistersMeta \u00b6 Request & Response PDUs for function #4/Read Input Registers. ReadInputRegistersRequest \u00b6 Concrete PDU implementation for handling function #4/Read Input Registers request messages. execute ( self , context ) \u00b6 FIXME if we ever implement a server. Source code in givenergy_modbus/pdu.py def execute ( self , context ) -> ModbusResponse : \"\"\"FIXME if we ever implement a server.\"\"\" raise NotImplementedError () ReadInputRegistersResponse \u00b6 Concrete PDU implementation for handling function #4/Read Input Registers response messages. ReadRegistersRequest \u00b6 Handles all messages that request a range of registers. __init__ ( self , ** kwargs ) special \u00b6 Proxy to the lower level initializer Source code in givenergy_modbus/pdu.py def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) self . base_register = kwargs . get ( 'base_register' , 0x0000 ) self . register_count = kwargs . get ( 'register_count' , 0x0000 ) ReadRegistersResponse \u00b6 Handles all messages that respond with a range of registers. __init__ ( self , ** kwargs ) special \u00b6 Proxy to the lower level initializer Source code in givenergy_modbus/pdu.py def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) self . inverter_serial_number : str = kwargs . get ( 'inverter_serial_number' , 'SA1234G567' ) self . base_register : int = kwargs . get ( 'base_register' , 0x0000 ) self . register_count : int = kwargs . get ( 'register_count' , 0x0000 ) self . register_values : list [ int ] = kwargs . get ( 'register_values' , []) if self . register_count != len ( self . register_values ): raise ValueError ( f 'Expected to receive { self . register_count } register values, ' f 'instead received { len ( self . register_values ) } .' , self , ) # self.check: int = kwargs.get('check', 0x0000) to_dict ( self ) \u00b6 Return the registers as a dict of register_index:value. Accounts for base_register offsets. Source code in givenergy_modbus/pdu.py def to_dict ( self ): \"\"\"Return the registers as a dict of register_index:value. Accounts for base_register offsets.\"\"\" return { k : v for k , v in enumerate ( self . register_values , start = self . base_register )} WriteHoldingRegisterMeta \u00b6 Request & Response PDUs for function #6/Write Holding Register. WriteHoldingRegisterRequest \u00b6 Concrete PDU implementation for handling function #6/Write Holding Register request messages. WriteHoldingRegisterResponse \u00b6 Concrete PDU implementation for handling function #6/Write Holding Register response messages. transaction \u00b6 GivEnergyTransactionManager \u00b6 Implements a ModbusTransactionManager. The only reason this exists is to be able to specify the ADU size for automated response frame processing since the socket needs to know how many bytes to expect in response to a given Request. See ModbusTransactionManager::execute where it checks whether the framer is an instance of ModbusSocketFramer to inform the expected response length, and even lower down the call chain in ModbusTransactionManager::_recv where there's more byte calculations based on the TransactionManager's provenance. We could've extended GivEnergyModbusFramer from ModbusSocketFramer instead, but that brings a different set of problems around implementation divergence in the GivEnergy implementation that would probably have been more work instead. Full novel in the GivEnergyModbusFramer class description. execute ( self , request ) \u00b6 Main processing loop. Source code in givenergy_modbus/transaction.py def execute ( self , request : ModbusPDU ) -> ModbusPDU : \"\"\"Main processing loop.\"\"\" res = super () . execute ( request ) _logger . debug ( f 'Old implementation returned: execute(request)= { res } ' ) return res util \u00b6 InterceptHandler \u00b6 Install loguru by intercepting logging. emit ( self , record ) \u00b6 Redirect logging emissions to loguru instead. Source code in givenergy_modbus/util.py def emit ( self , record ): \"\"\"Redirect logging emissions to loguru instead.\"\"\" # Get corresponding Loguru level if it exists try : level = logger . level ( record . levelname ) . name except ValueError : level = record . levelno # Find caller from where originated the logged message frame , depth = logging . currentframe (), 2 while frame . f_code . co_filename == logging . __file__ : frame = frame . f_back depth += 1 logger . opt ( depth = depth , exception = record . exc_info ) . log ( level , record . getMessage ()) friendly_class_name ( c ) \u00b6 Provides an easy way to only show the class name. Source code in givenergy_modbus/util.py def friendly_class_name ( c : Any ): \"\"\"Provides an easy way to only show the class name.\"\"\" if inspect . isclass ( c ): return str ( c )[ 8 : - 2 ] . rsplit ( \".\" , maxsplit = 1 )[ - 1 ] return friendly_class_name ( c . __class__ ) # + f'({vars(c)})' hexlify ( val ) \u00b6 Provides an easy way to print long byte strings as hex strings. Source code in givenergy_modbus/util.py def hexlify ( val ) -> str : \"\"\"Provides an easy way to print long byte strings as hex strings.\"\"\" if isinstance ( val , int ): val = val . to_bytes (( val . bit_length () + 8 ) // 8 , 'big' ) if isinstance ( val , bytes ): if sys . version_info < ( 3 , 8 ): # TODO remove once 3.7 is unsupported return binascii . hexlify ( val ) . decode ( 'ascii' ) return binascii . hexlify ( val , sep = ' ' , bytes_per_sep = 2 ) . decode ( 'ascii' ) return str ( val ) hexxed ( val ) \u00b6 Provides an easy way to print hex values when you might not always have ints. Source code in givenergy_modbus/util.py def hexxed ( val ): \"\"\"Provides an easy way to print hex values when you might not always have ints.\"\"\" if isinstance ( val , ( int , bytes )): return f '0x { val : 04x } ' return val","title":"Modules"},{"location":"api/#givenergy_modbus.cli","text":"Console script for interacting with GivEnergy inverters.","title":"cli"},{"location":"api/#givenergy_modbus.cli.is_documented_by","text":"Copies the docstring from the original source to the decorated target. Source code in givenergy_modbus/cli.py def is_documented_by ( original ): \"\"\"Copies the docstring from the original source to the decorated target.\"\"\" def wrapper ( target ): target . __doc__ = original . __doc__ return target return wrapper","title":"is_documented_by()"},{"location":"api/#givenergy_modbus.client","text":"","title":"client"},{"location":"api/#givenergy_modbus.client.GivEnergyClient","text":"Client for end users to conveniently access GivEnergy inverters.","title":"GivEnergyClient"},{"location":"api/#givenergy_modbus.client.GivEnergyClient.disable_charge","text":"Disable the battery from charging. Source code in givenergy_modbus/client.py def disable_charge ( self ): \"\"\"Disable the battery from charging.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . ENABLE_CHARGE , False )","title":"disable_charge()"},{"location":"api/#givenergy_modbus.client.GivEnergyClient.disable_charge_target","text":"Removes SOC limit and target 100% charging. Source code in givenergy_modbus/client.py def disable_charge_target ( self ): \"\"\"Removes SOC limit and target 100% charging.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . ENABLE_CHARGE_TARGET , False ) self . modbus_client . write_holding_register ( HoldingRegister . CHARGE_TARGET_SOC , 100 )","title":"disable_charge_target()"},{"location":"api/#givenergy_modbus.client.GivEnergyClient.disable_discharge","text":"Set the battery to not discharge at all. Source code in givenergy_modbus/client.py def disable_discharge ( self ): \"\"\"Set the battery to not discharge at all.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . ENABLE_DISCHARGE , False )","title":"disable_discharge()"},{"location":"api/#givenergy_modbus.client.GivEnergyClient.enable_charge","text":"Set the battery to charge, depending on the mode and slots set. Source code in givenergy_modbus/client.py def enable_charge ( self ): \"\"\"Set the battery to charge, depending on the mode and slots set.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . ENABLE_CHARGE , True )","title":"enable_charge()"},{"location":"api/#givenergy_modbus.client.GivEnergyClient.enable_charge_target","text":"Sets inverter to stop charging when SOC reaches the desired level. Also referred to as \"winter mode\". Source code in givenergy_modbus/client.py def enable_charge_target ( self , target_soc : int ): \"\"\"Sets inverter to stop charging when SOC reaches the desired level. Also referred to as \"winter mode\".\"\"\" if not 4 <= target_soc <= 100 : raise ValueError ( f 'Specified Charge Target SOC ( { target_soc } ) is not in [4-100]' ) if target_soc == 100 : self . disable_charge_target () else : self . modbus_client . write_holding_register ( HoldingRegister . ENABLE_CHARGE_TARGET , True ) self . modbus_client . write_holding_register ( HoldingRegister . CHARGE_TARGET_SOC , target_soc )","title":"enable_charge_target()"},{"location":"api/#givenergy_modbus.client.GivEnergyClient.enable_discharge","text":"Set the battery to discharge, depending on the mode and slots set. Source code in givenergy_modbus/client.py def enable_discharge ( self ): \"\"\"Set the battery to discharge, depending on the mode and slots set.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . ENABLE_DISCHARGE , True )","title":"enable_discharge()"},{"location":"api/#givenergy_modbus.client.GivEnergyClient.fetch_register_pages","text":"Reload all inverter data from the device. Source code in givenergy_modbus/client.py def fetch_register_pages ( self , pages : Mapping [ type [ HoldingRegister | InputRegister ], Sequence [ int ]], register_cache : RegisterCache , slave_address : int = 0x32 , sleep_between_queries : float = DEFAULT_SLEEP , ) -> None : \"\"\"Reload all inverter data from the device.\"\"\" for register , base_registers in pages . items (): for base_register in base_registers : data = self . modbus_client . read_registers ( register , base_register , 60 , slave_address = slave_address ) register_cache . set_registers ( register , data ) t . sleep ( sleep_between_queries )","title":"fetch_register_pages()"},{"location":"api/#givenergy_modbus.client.GivEnergyClient.reset_charge_slot_1","text":"Reset first charge slot times to zero/disabled. Source code in givenergy_modbus/client.py def reset_charge_slot_1 ( self ): \"\"\"Reset first charge slot times to zero/disabled.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . CHARGE_SLOT_1_START , 0 ) self . modbus_client . write_holding_register ( HoldingRegister . CHARGE_SLOT_1_END , 0 )","title":"reset_charge_slot_1()"},{"location":"api/#givenergy_modbus.client.GivEnergyClient.reset_charge_slot_2","text":"Reset second charge slot times to zero/disabled. Source code in givenergy_modbus/client.py def reset_charge_slot_2 ( self ): \"\"\"Reset second charge slot times to zero/disabled.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . CHARGE_SLOT_2_START , 0 ) self . modbus_client . write_holding_register ( HoldingRegister . CHARGE_SLOT_2_END , 0 )","title":"reset_charge_slot_2()"},{"location":"api/#givenergy_modbus.client.GivEnergyClient.reset_discharge_slot_1","text":"Reset first discharge slot times to zero/disabled. Source code in givenergy_modbus/client.py def reset_discharge_slot_1 ( self ): \"\"\"Reset first discharge slot times to zero/disabled.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . DISCHARGE_SLOT_1_START , 0 ) self . modbus_client . write_holding_register ( HoldingRegister . DISCHARGE_SLOT_1_END , 0 )","title":"reset_discharge_slot_1()"},{"location":"api/#givenergy_modbus.client.GivEnergyClient.reset_discharge_slot_2","text":"Reset first discharge slot times to zero/disabled. Source code in givenergy_modbus/client.py def reset_discharge_slot_2 ( self ): \"\"\"Reset first discharge slot times to zero/disabled.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . DISCHARGE_SLOT_2_START , 0 ) self . modbus_client . write_holding_register ( HoldingRegister . DISCHARGE_SLOT_2_END , 0 )","title":"reset_discharge_slot_2()"},{"location":"api/#givenergy_modbus.client.GivEnergyClient.set_battery_charge_limit","text":"Set the battery charge limit. Source code in givenergy_modbus/client.py def set_battery_charge_limit ( self , val : int ): \"\"\"Set the battery charge limit.\"\"\" # TODO what are valid values? if not 0 <= val <= 50 : raise ValueError ( f 'Specified Charge Limit ( { val } %) is not in [0-50]%' ) self . modbus_client . write_holding_register ( HoldingRegister . BATTERY_CHARGE_LIMIT , val )","title":"set_battery_charge_limit()"},{"location":"api/#givenergy_modbus.client.GivEnergyClient.set_battery_discharge_limit","text":"Set the battery discharge limit. Source code in givenergy_modbus/client.py def set_battery_discharge_limit ( self , val : int ): \"\"\"Set the battery discharge limit.\"\"\" if not 0 <= val <= 50 : raise ValueError ( f 'Specified Discharge Limit ( { val } %) is not in [0-50]%' ) self . modbus_client . write_holding_register ( HoldingRegister . BATTERY_DISCHARGE_LIMIT , val )","title":"set_battery_discharge_limit()"},{"location":"api/#givenergy_modbus.client.GivEnergyClient.set_battery_discharge_mode_demand","text":"Set the battery to discharge to match demand (no export) when discharging. Source code in givenergy_modbus/client.py def set_battery_discharge_mode_demand ( self ): \"\"\"Set the battery to discharge to match demand (no export) when discharging.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . BATTERY_POWER_MODE , 1 )","title":"set_battery_discharge_mode_demand()"},{"location":"api/#givenergy_modbus.client.GivEnergyClient.set_battery_discharge_mode_max_power","text":"Set the battery to discharge at maximum power (export) when discharging. Source code in givenergy_modbus/client.py def set_battery_discharge_mode_max_power ( self ): \"\"\"Set the battery to discharge at maximum power (export) when discharging.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . BATTERY_POWER_MODE , 0 )","title":"set_battery_discharge_mode_max_power()"},{"location":"api/#givenergy_modbus.client.GivEnergyClient.set_battery_power_reserve","text":"Set the battery power reserve to maintain. Source code in givenergy_modbus/client.py def set_battery_power_reserve ( self , val : int ): \"\"\"Set the battery power reserve to maintain.\"\"\" # TODO what are valid values? self . modbus_client . write_holding_register ( HoldingRegister . BATTERY_DISCHARGE_MIN_POWER_RESERVE , val )","title":"set_battery_power_reserve()"},{"location":"api/#givenergy_modbus.client.GivEnergyClient.set_battery_target_soc","text":"Set the target SOC when the battery charges. Source code in givenergy_modbus/client.py def set_battery_target_soc ( self , val : int ): \"\"\"Set the target SOC when the battery charges.\"\"\" # TODO what are valid values? self . modbus_client . write_holding_register ( HoldingRegister . CHARGE_TARGET_SOC , val )","title":"set_battery_target_soc()"},{"location":"api/#givenergy_modbus.client.GivEnergyClient.set_charge_slot_1","text":"Set first charge slot times. Source code in givenergy_modbus/client.py def set_charge_slot_1 ( self , times : tuple [ time , time ]): \"\"\"Set first charge slot times.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . CHARGE_SLOT_1_START , int ( times [ 0 ] . strftime ( '%H%M' ))) self . modbus_client . write_holding_register ( HoldingRegister . CHARGE_SLOT_1_END , int ( times [ 1 ] . strftime ( '%H%M' )))","title":"set_charge_slot_1()"},{"location":"api/#givenergy_modbus.client.GivEnergyClient.set_charge_slot_2","text":"Set second charge slot times. Source code in givenergy_modbus/client.py def set_charge_slot_2 ( self , times : tuple [ time , time ]): \"\"\"Set second charge slot times.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . CHARGE_SLOT_2_START , int ( times [ 0 ] . strftime ( '%H%M' ))) self . modbus_client . write_holding_register ( HoldingRegister . CHARGE_SLOT_2_END , int ( times [ 1 ] . strftime ( '%H%M' )))","title":"set_charge_slot_2()"},{"location":"api/#givenergy_modbus.client.GivEnergyClient.set_datetime","text":"Set the date & time of the inverter. Source code in givenergy_modbus/client.py def set_datetime ( self , dt : datetime ): \"\"\"Set the date & time of the inverter.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . SYSTEM_TIME_YEAR , dt . year ) self . modbus_client . write_holding_register ( HoldingRegister . SYSTEM_TIME_MONTH , dt . month ) self . modbus_client . write_holding_register ( HoldingRegister . SYSTEM_TIME_DAY , dt . day ) self . modbus_client . write_holding_register ( HoldingRegister . SYSTEM_TIME_HOUR , dt . hour ) self . modbus_client . write_holding_register ( HoldingRegister . SYSTEM_TIME_MINUTE , dt . minute ) self . modbus_client . write_holding_register ( HoldingRegister . SYSTEM_TIME_SECOND , dt . second )","title":"set_datetime()"},{"location":"api/#givenergy_modbus.client.GivEnergyClient.set_discharge_enable","text":"Set the battery to discharge. Source code in givenergy_modbus/client.py def set_discharge_enable ( self , mode : bool ): \"\"\"Set the battery to discharge.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . ENABLE_DISCHARGE , int ( mode ))","title":"set_discharge_enable()"},{"location":"api/#givenergy_modbus.client.GivEnergyClient.set_discharge_slot_1","text":"Set first discharge slot times. Source code in givenergy_modbus/client.py def set_discharge_slot_1 ( self , times : tuple [ time , time ]): \"\"\"Set first discharge slot times.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . DISCHARGE_SLOT_1_START , int ( times [ 0 ] . strftime ( '%H%M' )) ) self . modbus_client . write_holding_register ( HoldingRegister . DISCHARGE_SLOT_1_END , int ( times [ 1 ] . strftime ( '%H%M' )))","title":"set_discharge_slot_1()"},{"location":"api/#givenergy_modbus.client.GivEnergyClient.set_discharge_slot_2","text":"Set second discharge slot times. Source code in givenergy_modbus/client.py def set_discharge_slot_2 ( self , times : tuple [ time , time ]): \"\"\"Set second discharge slot times.\"\"\" self . modbus_client . write_holding_register ( HoldingRegister . DISCHARGE_SLOT_2_START , int ( times [ 0 ] . strftime ( '%H%M' )) ) self . modbus_client . write_holding_register ( HoldingRegister . DISCHARGE_SLOT_2_END , int ( times [ 1 ] . strftime ( '%H%M' )))","title":"set_discharge_slot_2()"},{"location":"api/#givenergy_modbus.client.GivEnergyClient.set_mode_dynamic","text":"Set system to Dynamic / Eco mode. This mode is designed to maximise use of solar generation. The battery will charge when there is excess power being generated from your solar panels. The battery will store and hold this energy until your demand increases. The system will try and balance the use of solar and battery so that you are importing and exporting as little energy as possible. This mode is useful if you want to maximise self-consumption of renewable generation and minimise the amount of energy drawn from the grid. Source code in givenergy_modbus/client.py def set_mode_dynamic ( self ): \"\"\"Set system to Dynamic / Eco mode. This mode is designed to maximise use of solar generation. The battery will charge when there is excess power being generated from your solar panels. The battery will store and hold this energy until your demand increases. The system will try and balance the use of solar and battery so that you are importing and exporting as little energy as possible. This mode is useful if you want to maximise self-consumption of renewable generation and minimise the amount of energy drawn from the grid. \"\"\" self . set_battery_discharge_mode_demand () # r27=1 self . set_shallow_charge ( 4 ) # r110=4 self . disable_discharge () # r59=0","title":"set_mode_dynamic()"},{"location":"api/#givenergy_modbus.client.GivEnergyClient.set_mode_storage","text":"Set system to storage mode with specific discharge slots(s). This mode stores excess solar generation during the day and holds that energy ready for use later in the day. By default, the battery will start to discharge from 4pm-7am to cover energy demand during typical peak hours. This mode is particularly useful if you get charged more for your electricity at certain times to utilise the battery when it is most effective. If the second time slot isn't specified, it will be cleared. You can optionally also choose to export excess energy: instead of discharging to meet only your home demand, the battery will discharge at full power and any excess will be exported to the grid. This is useful if you have a variable export tariff (e.g. Agile export) and you want to target the peak times of day (e.g. 4pm-7pm) when it is both most expensive to import and most valuable to export energy. Source code in givenergy_modbus/client.py def set_mode_storage ( self , slot_1 : tuple [ time , time ] = ( time ( hour = 16 ), time ( hour = 7 )), slot_2 : tuple [ time , time ] = None , export = False ): \"\"\"Set system to storage mode with specific discharge slots(s). This mode stores excess solar generation during the day and holds that energy ready for use later in the day. By default, the battery will start to discharge from 4pm-7am to cover energy demand during typical peak hours. This mode is particularly useful if you get charged more for your electricity at certain times to utilise the battery when it is most effective. If the second time slot isn't specified, it will be cleared. You can optionally also choose to export excess energy: instead of discharging to meet only your home demand, the battery will discharge at full power and any excess will be exported to the grid. This is useful if you have a variable export tariff (e.g. Agile export) and you want to target the peak times of day (e.g. 4pm-7pm) when it is both most expensive to import and most valuable to export energy. \"\"\" if export : self . set_battery_discharge_mode_max_power () # r27=0 else : self . set_battery_discharge_mode_demand () # r27=1 self . set_shallow_charge ( 100 ) # r110=100 self . enable_discharge () # r59=1 self . set_discharge_slot_1 ( slot_1 ) # r56=1600, r57=700 if slot_2 : self . set_discharge_slot_1 ( slot_2 ) # r56=1600, r57=700 else : self . reset_discharge_slot_2 ()","title":"set_mode_storage()"},{"location":"api/#givenergy_modbus.client.GivEnergyClient.set_shallow_charge","text":"Set the minimum level of charge to keep. Source code in givenergy_modbus/client.py def set_shallow_charge ( self , val : int ): \"\"\"Set the minimum level of charge to keep.\"\"\" # TODO what are valid values? 4-100? self . modbus_client . write_holding_register ( HoldingRegister . BATTERY_SOC_RESERVE , val )","title":"set_shallow_charge()"},{"location":"api/#givenergy_modbus.client.GivEnergyClient.update_battery_registers","text":"Reload all battery data from a given device. Source code in givenergy_modbus/client.py def update_battery_registers ( self , register_cache : RegisterCache , sleep_between_queries = DEFAULT_SLEEP , battery_number = 0 ) -> None : \"\"\"Reload all battery data from a given device.\"\"\" self . fetch_register_pages ( BATTERY_REGISTER_PAGES , register_cache , slave_address = 0x32 + battery_number , sleep_between_queries = sleep_between_queries , )","title":"update_battery_registers()"},{"location":"api/#givenergy_modbus.client.GivEnergyClient.update_inverter_registers","text":"Reload inverter data and return an Inverter DTO. Source code in givenergy_modbus/client.py def update_inverter_registers ( self , register_cache : RegisterCache , sleep_between_queries = DEFAULT_SLEEP ) -> None : \"\"\"Reload inverter data and return an Inverter DTO.\"\"\" self . fetch_register_pages ( INVERTER_REGISTER_PAGES , register_cache , slave_address = 0x32 , sleep_between_queries = sleep_between_queries )","title":"update_inverter_registers()"},{"location":"api/#givenergy_modbus.decoder","text":"","title":"decoder"},{"location":"api/#givenergy_modbus.decoder.GivEnergyDecoder","text":"GivEnergy Modbus Decoder factory base class. This is to enable efficient decoding of unencapsulated messages (i.e. having the Modbus-specific framing stripped) and creating populated matching PDU DTO instances. Two factories are created, dealing with messages traveling in a particular direction (Request/Client vs. Response/Server) since implementations generally know what side of the conversation they'll be on. It does allow for more general ideas like being able to decode arbitrary streams of messages (i.e. captured from a network interface) where these classes may be intermixed. The Decoder's job is to do the bare minimum inspecting of the raw message to determine its type, instantiate a concrete PDU handler to decode it, and pass it on.","title":"GivEnergyDecoder"},{"location":"api/#givenergy_modbus.decoder.GivEnergyDecoder.decode","text":"Create an appropriately populated PDU message object from a valid Modbus message. Extracts the function code from the raw message and looks up the matching ModbusPDU handler class that claims that function. This handler is instantiated and passed the raw message, which then proceeds to decode its attributes from the bytestream. Source code in givenergy_modbus/decoder.py def decode ( self , data : bytes ) -> ModbusPDU | ErrorResponse | None : \"\"\"Create an appropriately populated PDU message object from a valid Modbus message. Extracts the `function code` from the raw message and looks up the matching ModbusPDU handler class that claims that function. This handler is instantiated and passed the raw message, which then proceeds to decode its attributes from the bytestream. \"\"\" main_fn = data [ 0 ] data = data [ 1 :] if main_fn == 0x1 : # heartbeat / error? err_response = ErrorResponse () _logger . debug ( f \"About to decode data [ { hexlify ( data ) } ]\" ) err_response . decode ( data ) return err_response elif main_fn == 0x2 : # most functions if len ( data ) <= 19 : _logger . error ( f \"PDU data is too short to find a valid function id: len= { len ( data ) } [ { hexlify ( data ) } ]\" ) return None fn_code = data [ 19 ] response = self . lookupPduClass ( fn_code ) if response : _logger . debug ( f \"About to decode data [ { hexlify ( data ) } ]\" ) r = response ( function_code = fn_code ) r . decode ( data ) return r _logger . error ( f \"No decoder for function code { fn_code } \" ) return None _logger . error ( f \"Unknown main function code { hex ( main_fn ) } \" ) # return ExceptionResponse(main_fn, ModbusExceptions.IllegalFunction) return None","title":"decode()"},{"location":"api/#givenergy_modbus.decoder.GivEnergyDecoder.lookupPduClass","text":"Attempts to find the ModbusPDU handler class that can handle a given function code. Source code in givenergy_modbus/decoder.py def lookupPduClass ( self , fn_code : int ) -> type [ ModbusPDU ] | None : \"\"\"Attempts to find the ModbusPDU handler class that can handle a given function code.\"\"\" if fn_code >= 0x80 : fn_code &= 0x7F if fn_code in self . _lookup : fn = self . _lookup [ fn_code ] _logger . debug ( f \"Identified incoming PDU as { fn_code } / { friendly_class_name ( fn ) } \" ) return fn return None","title":"lookupPduClass()"},{"location":"api/#givenergy_modbus.decoder.GivEnergyRequestDecoder","text":"Factory class to decode GivEnergy Request PDU messages. Typically used by servers processing inbound requests.","title":"GivEnergyRequestDecoder"},{"location":"api/#givenergy_modbus.decoder.GivEnergyResponseDecoder","text":"Factory class to decode GivEnergy Response PDU messages. Typically used by clients to process responses.","title":"GivEnergyResponseDecoder"},{"location":"api/#givenergy_modbus.framer","text":"","title":"framer"},{"location":"api/#givenergy_modbus.framer.GivEnergyModbusFramer","text":"GivEnergy Modbus Frame controller. A framer abstracts away all the detail about how marshall the wire protocol, e.g. to detect if a current message frame exists, decoding it, sending it, etc. This implementation understands the idiosyncrasies of GivEnergy's implementation of the Modbus spec. Note that the understanding below comes from observing the wire format and analysing the data interchanges \u2013 no GivEnergy proprietary knowledge was needed or referred to. Packet exchange looks very similar to normal Modbus TCP on the wire, with each message still having a regular 7-byte MBAP header consisting of: tid , the transaction id pid , the protocol id len , the byte count / length of the remaining data following the header uid , the unit id for addressing devices on the Modbus network This is followed by fid / a function code to specify how the message should be decoded into a PDU: [_________MBAP Header______] [_fid_] [_______________data________________] [_tid_][_pid_][_len_][_uid_] 2b 2b 2b 1b 1b (len-1)b GivEnergy's implementation quicks can be summarised as: tid is always 0x5959/'YY' , so the assumption/interpretation is that clients have to poll continually instead of maintaining long-lived connections and using varying tid s to pair requests with responses pid is always 0x0001 , whereas normal Modbus uses 0x0000 len adds 1 extra byte (anecdotally for the unit id?) which normal Modbus does not. This leads to continual off-by-one differences appearing whenever header/frame length calculations are done. This is probably the biggest reason Modbus libraries struggle working out of the box. unit_id is always 0x01 fid is always 0x02/Read Discrete Inputs even for requests that modify registers. The actual intended function is encoded 19 bytes into the data block. You can interpret this as functionally somewhat akin to Modbus sub-functions where we always use the 0x02 main function. Because these fields are static and we have to reinterpret what len means it is simpler to just reconsider the entire header: [___\"MBAP+\" Header____] [_______________GivEnergy Frame_______________] [___h1___][_len_][_h2_] 4b 2b 2b (len+2)b h1 is always 0x59590001 , so can be used as a sanity check during decoding len needs 2 added during calculations because of the previous extra byte off-by-one inconsistency, plus expanding the header by including 1-byte fid h2 is always 0x0102 , so can be used as a sanity check during decoding TODO These constant headers being present would allow for us to scan through the bytestream to try and recover from stream errors and help reset the framing. The GivEnergy frame itself has a consistent format: [____serial____] [___pad___] [_addr_] [_func_] [______data______] [_crc_] 10b 8b 1b 1b Nb 2b serial of the responding data adapter (wifi/GPRS?/ethernet?) plugged into the inverter. For requests this is simply hardcoded as a dummy AB1234G567 pad 's function is unknown - it appears to be a single zero-padded byte that varies across responses, so might be some kind of check/crc? addr is the \"slave\" address, conventionally 0x32 func is the actual function to be executed: 0x3 - read holding registers 0x4 - read input registers 0x6 - write single register data is specific to the invoked function crc - for requests it is calculated using the function id, base register and step count, but it is not clear how those for responses are calculated (or should be checked) In short, the message unframing algorithm is simply: while len ( buffer ) > 8 : tid , pid , len , uid , fid = struct . unpack ( \">HHHBB\" , buffer ) data = buffer [ 8 : 6 + len ] process_message ( tid , pid , len , uid , fid , data ) buffer = buffer [ 6 + len :] # skip buffer over frame Exceptions: Type Description InvalidMessageReceivedException When unable to decode an incoming message. ModbusIOException When the identified function decoder fails to decode a message.","title":"GivEnergyModbusFramer"},{"location":"api/#givenergy_modbus.framer.GivEnergyModbusFramer.addToFrame","text":"Add incoming data to the processing buffer. Source code in givenergy_modbus/framer.py def addToFrame ( self , message : bytes ) -> None : \"\"\"Add incoming data to the processing buffer.\"\"\" self . _buffer += message","title":"addToFrame()"},{"location":"api/#givenergy_modbus.framer.GivEnergyModbusFramer.advanceFrame","text":"Pop the front-most frame from the buffer. Source code in givenergy_modbus/framer.py def advanceFrame ( self ): \"\"\"Pop the front-most frame from the buffer.\"\"\" length = self . _hsize + self . _length - 2 _logger . debug ( f 'length { length } = { self . _hsize } + { self . _length } - 2, len(buffer) = { len ( self . _buffer ) } ' ) self . _buffer = self . _buffer [ length :] _logger . debug ( f \"buffer is now { len ( self . _buffer ) } bytes: { self . _buffer } \" ) self . _length = 0","title":"advanceFrame()"},{"location":"api/#givenergy_modbus.framer.GivEnergyModbusFramer.buildPacket","text":"Creates a finalised GivEnergy Modbus packet from a constant header plus the encoded PDU. Source code in givenergy_modbus/framer.py def buildPacket ( self , message : ModbusPDU ) -> bytes : \"\"\"Creates a finalised GivEnergy Modbus packet from a constant header plus the encoded PDU.\"\"\" return struct . pack ( self . FRAME_HEAD , 0x5959 , 0x0001 , len ( message . encode ()) + 2 , 0x01 , 0x02 ) + message . encode ()","title":"buildPacket()"},{"location":"api/#givenergy_modbus.framer.GivEnergyModbusFramer.checkFrame","text":"Check and decode the next frame. Returns operation success. Source code in givenergy_modbus/framer.py def checkFrame ( self ) -> bool : \"\"\"Check and decode the next frame. Returns operation success.\"\"\" if self . isFrameReady (): _logger . debug ( 'Frame header should be ready' ) header = self . decode_data () if not header : _logger . debug ( 'Frame header is corrupt, resetting frame' ) # self.resetFrame() return False self . _fcode = header [ \"fcode\" ] self . _length = header [ \"length\" ] # this short a message should not be possible? if self . _length < 2 : _logger . warning ( f \"unexpected short message length { self . _length } , advancing frame\" ) self . advanceFrame () return False # we have at least a complete message, continue if len ( self . _buffer ) >= self . _hsize + self . _length - 2 : return True _logger . debug ( f 'Incomplete message: len(buffer)= { len ( self . _buffer ) } < hsize= { self . _hsize } + length= { self . _length } - 2' ) # we don't have enough of a message yet, try again later _logger . debug ( 'Frame is not complete yet, needs more buffer data' ) return False","title":"checkFrame()"},{"location":"api/#givenergy_modbus.framer.GivEnergyModbusFramer.decode_data","text":"Tries to extract the MBAP frame header and performs a few sanity checks. Source code in givenergy_modbus/framer.py def decode_data ( self , data : bytes = None ) -> dict | None : \"\"\"Tries to extract the MBAP frame header and performs a few sanity checks.\"\"\" if not data : data = self . _buffer [: self . _hsize ] if self . isFrameReady (): _logger . debug ( f \"extracting MBAP header from [ { hexlify ( data ) } ] as { self . FRAME_HEAD } \" ) tid , pid , len_ , uid , fid = struct . unpack ( self . FRAME_HEAD , data ) header = dict ( transaction = tid , protocol = pid , length = len_ , unit = uid , fcode = fid ) _logger . debug ( f \"extracted values: { dict (( k , f '0x { v : 02x } ' ) for k , v in header . items ()) } \" ) if tid != 0x5959 or pid != 0x1 or uid != 0x1 : # or fid != 0x2: _logger . debug ( f \"Invalid MBAP header; corruption likely so cowardly refusing to proceed with this frame. \" f \"(0x { tid : 04x } 0x { pid : 04x } 0x { uid : 02x } != 0x5959 0x0001 0x01)\" ) return None return header return None","title":"decode_data()"},{"location":"api/#givenergy_modbus.framer.GivEnergyModbusFramer.getFrame","text":"Extract the next PDU frame from the buffer, discarding the leading MBAP header. Source code in givenergy_modbus/framer.py def getFrame ( self ): \"\"\"Extract the next PDU frame from the buffer, discarding the leading MBAP header.\"\"\" return self . _buffer [ self . _hsize - 1 : self . _hsize + self . _length ]","title":"getFrame()"},{"location":"api/#givenergy_modbus.framer.GivEnergyModbusFramer.getRawFrame","text":"Returns the complete buffer. Source code in givenergy_modbus/framer.py def getRawFrame ( self ): \"\"\"Returns the complete buffer.\"\"\" return self . _buffer","title":"getRawFrame()"},{"location":"api/#givenergy_modbus.framer.GivEnergyModbusFramer.isFrameReady","text":"Check if we have enough data in the buffer to read at least a frame header. Source code in givenergy_modbus/framer.py def isFrameReady ( self ): \"\"\"Check if we have enough data in the buffer to read at least a frame header.\"\"\" return len ( self . _buffer ) >= self . _hsize","title":"isFrameReady()"},{"location":"api/#givenergy_modbus.framer.GivEnergyModbusFramer.populateResult","text":"Populates the Modbus PDU object's metadata attributes from the decoded MBAP headers. Source code in givenergy_modbus/framer.py def populateResult ( self , result : ModbusPDU ): \"\"\"Populates the Modbus PDU object's metadata attributes from the decoded MBAP headers.\"\"\" # no-op, there's nothing interesting in there","title":"populateResult()"},{"location":"api/#givenergy_modbus.framer.GivEnergyModbusFramer.processIncomingPacket","text":"Process an incoming packet. This takes in a bytestream from the underlying transport and adds it to the frame buffer. It then repeatedly attempts to perform framing on the buffer by checking for a viable message at the head of the buffer, and if found pops off the expected length of the raw frame for processing. Returns when the buffer is too short to contain any more viable messages. This handles cases where multiple and/or partial messages arrive due to fragmentation or buffering on the underlying transport - these partial messages will try to be completed eventually as more data subsequently arrives and gets handled here. If decoding and processing succeeds for a message, the instantiated PDU DTO is handed to the supplied callback function for onward processing and dispatching. Parameters: Name Type Description Default data bytes Data from underlying transport. required callback Callable Processor to receive newly-decoded PDUs. required Source code in givenergy_modbus/framer.py def processIncomingPacket ( self , data : bytes , callback : Callable , * args , ** kwargs ) -> None : \"\"\"Process an incoming packet. This takes in a bytestream from the underlying transport and adds it to the frame buffer. It then repeatedly attempts to perform framing on the buffer by checking for a viable message at the head of the buffer, and if found pops off the expected length of the raw frame for processing. Returns when the buffer is too short to contain any more viable messages. This handles cases where multiple and/or partial messages arrive due to fragmentation or buffering on the underlying transport - these partial messages will try to be completed eventually as more data subsequently arrives and gets handled here. If decoding and processing succeeds for a message, the instantiated PDU DTO is handed to the supplied callback function for onward processing and dispatching. Args: data: Data from underlying transport. callback: Processor to receive newly-decoded PDUs. \"\"\" _logger . debug ( f 'Incoming { len ( data ) } bytes: { hexlify_packets ( data ) } ' ) self . addToFrame ( data ) while True : if not self . isFrameReady (): _logger . debug ( 'No more frames waiting, exiting' ) break if not self . checkFrame (): _logger . debug ( \"Frame check failed, dropping and resetting!!\" ) self . resetFrame () else : _logger . debug ( 'Hand off to _process' ) self . _process ( callback )","title":"processIncomingPacket()"},{"location":"api/#givenergy_modbus.framer.GivEnergyModbusFramer.resetFrame","text":"Reset the entire message buffer. Source code in givenergy_modbus/framer.py def resetFrame ( self ): \"\"\"Reset the entire message buffer.\"\"\" # try to mitigate corruption: if we can find the start of another MBAP header truncate the buffer # only up to that point header_offset = self . _buffer . find ( b ' \\x59\\x59\\x00\\x01 ' , 1 ) if header_offset > 0 : _logger . info ( f 'Found another MBAP header at offset { header_offset } in buffer { hexlify ( self . _buffer ) } , ' 'attempting recovery.' ) self . _buffer = self . _buffer [ header_offset :] else : self . _buffer = b \"\" self . _length = 0","title":"resetFrame()"},{"location":"api/#givenergy_modbus.modbus","text":"","title":"modbus"},{"location":"api/#givenergy_modbus.modbus.GivEnergyModbusTcpClient","text":"GivEnergy Modbus Client implementation. This class ties together all the pieces to create a functional client that can converse with a GivEnergy Modbus implementation over TCP. It exists as a thin wrapper around the ModbusTcpClient to hot patch in our own Framer and TransactionManager since they are hardcoded classes for Decoder and TransactionManager throughout constructors up the call chain. We also provide a few convenience methods to read and write registers.","title":"GivEnergyModbusTcpClient"},{"location":"api/#givenergy_modbus.modbus.GivEnergyModbusTcpClient.execute","text":"Send the given PDU to the remote device and return any PDU returned in response. Source code in givenergy_modbus/modbus.py def execute ( self , request : ModbusPDU = None ) -> ModbusPDU | None : \"\"\"Send the given PDU to the remote device and return any PDU returned in response.\"\"\" _logger . debug ( f 'Sending request { request } ' ) try : response = super () . execute ( request ) if isinstance ( response , ModbusIOException ): _logger . exception ( response ) return response except ModbusIOException as e : _logger . exception ( e ) self . close () return None except Exception as e : # This seems to help with inverters becoming unresponsive from the portal.\"\"\" _logger . exception ( e ) self . close () return None","title":"execute()"},{"location":"api/#givenergy_modbus.modbus.GivEnergyModbusTcpClient.read_holding_registers","text":"Convenience method to help read out holding registers. Source code in givenergy_modbus/modbus.py def read_holding_registers ( self , address , count = 1 , ** kwargs ) -> dict [ int , int ]: \"\"\"Convenience method to help read out holding registers.\"\"\" return self . read_registers ( HoldingRegister , address , count , ** kwargs )","title":"read_holding_registers()"},{"location":"api/#givenergy_modbus.modbus.GivEnergyModbusTcpClient.read_input_registers","text":"Convenience method to help read out input registers. Source code in givenergy_modbus/modbus.py def read_input_registers ( self , address , count = 1 , ** kwargs ) -> dict [ int , int ]: \"\"\"Convenience method to help read out input registers.\"\"\" return self . read_registers ( InputRegister , address , count , ** kwargs )","title":"read_input_registers()"},{"location":"api/#givenergy_modbus.modbus.GivEnergyModbusTcpClient.read_registers","text":"Read out registers from the correct location depending on type specified. Source code in givenergy_modbus/modbus.py def read_registers ( self , kind : type [ HoldingRegister | InputRegister ], base_address : int , register_count : int , ** kwargs ) -> dict [ int , int ]: \"\"\"Read out registers from the correct location depending on type specified.\"\"\" # match types of register to their request/response types t_req , t_res = { HoldingRegister : ( ReadHoldingRegistersRequest , ReadHoldingRegistersResponse ), InputRegister : ( ReadInputRegistersRequest , ReadInputRegistersResponse ), }[ kind ] request = t_req ( base_register = base_address , register_count = register_count , ** kwargs ) _logger . debug ( f 'Attempting to read { t_req } s # { request . base_register } -' f ' { request . base_register + request . register_count } from device { hex ( request . slave_address ) } ...' ) response = self . execute ( request ) if response and isinstance ( response , t_res ): if response . base_register != base_address : _logger . error ( f 'Returned base register ( { response . base_register } ) ' f 'does not match that from request ( { base_address } ).' ) return {} if response . register_count != register_count : _logger . error ( f 'Returned register count ( { response . register_count } ) ' f 'does not match that from request ( { register_count } ).' ) return {} return response . to_dict () _logger . error ( f 'Did not receive expected response type: { t_res . __name__ } != { response . __class__ . __name__ } ' ) # FIXME this contract needs improving return {}","title":"read_registers()"},{"location":"api/#givenergy_modbus.modbus.GivEnergyModbusTcpClient.write_holding_register","text":"Write a value to a single holding register. Source code in givenergy_modbus/modbus.py def write_holding_register ( self , register : HoldingRegister , value : int ) -> None : \"\"\"Write a value to a single holding register.\"\"\" if not register . write_safe : # type: ignore # shut up mypy raise ValueError ( f 'Register { register . name } is not safe to write to' ) if value != value & 0xFFFF : raise ValueError ( f 'Value { value } must fit in 2 bytes' ) _logger . info ( f 'Attempting to write { value } / { hex ( value ) } to Holding Register { register . value } / { register . name } ' ) request = WriteHoldingRegisterRequest ( register = register . value , value = value ) result = self . execute ( request ) if isinstance ( result , WriteHoldingRegisterResponse ): if result . value != value : raise AssertionError ( f 'Register read-back value 0x { result . value : 04x } != written value 0x { value : 04x } ' ) else : raise AssertionError ( f 'Unexpected response from remote end: { result } ' )","title":"write_holding_register()"},{"location":"api/#givenergy_modbus.model","text":"Data model.","title":"model"},{"location":"api/#givenergy_modbus.model.GivEnergyBaseModel","text":"Structured format for all other attributes.","title":"GivEnergyBaseModel"},{"location":"api/#givenergy_modbus.model.GivEnergyBaseModel.Config","text":"","title":"Config"},{"location":"api/#givenergy_modbus.model.GivEnergyBaseModel.Config.getter_dict","text":"GetterDict implementation to consolidate register data structures.","title":"getter_dict"},{"location":"api/#givenergy_modbus.model.GivEnergyBaseModel.Config.getter_dict.get","text":"Getter that computes some virtual attributes. Source code in givenergy_modbus/model/__init__.py def get ( self , key : Any , default : Any = None ) -> Any : \"\"\"Getter that computes some virtual attributes.\"\"\" if key == \"inverter_serial_number\" : return '' . join ( [ self . get ( 'inverter_serial_number_1_2' ), self . get ( 'inverter_serial_number_3_4' ), self . get ( 'inverter_serial_number_5_6' ), self . get ( 'inverter_serial_number_7_8' ), self . get ( 'inverter_serial_number_9_10' ), ] ) if key in [ \"num_mppt\" , 'num_phases' ]: obj = self . get ( 'num_mppt_and_num_phases' ) if obj == default : return default elif key == \"num_mppt\" : return obj [ 0 ] return obj [ 1 ] if key == \"battery_serial_number\" : return '' . join ( [ self . get ( 'battery_serial_number_1_2' ), self . get ( 'battery_serial_number_3_4' ), self . get ( 'battery_serial_number_5_6' ), self . get ( 'battery_serial_number_7_8' ), self . get ( 'battery_serial_number_9_10' ), ] ) if key == \"first_battery_serial_number\" : return '' . join ( [ self . get ( 'first_battery_serial_number_1_2' ), self . get ( 'first_battery_serial_number_3_4' ), self . get ( 'first_battery_serial_number_5_6' ), self . get ( 'first_battery_serial_number_7_8' ), self . get ( 'first_battery_serial_number_9_10' ), ] ) # Some special cases first if key == \"system_time\" : return datetime ( self . get ( 'system_time_year' ) + 2000 , self . get ( 'system_time_month' ), self . get ( 'system_time_day' ), self . get ( 'system_time_hour' ), self . get ( 'system_time_minute' ), self . get ( 'system_time_second' ), ) if key in ( 'charge_slot_1' , 'charge_slot_2' , 'discharge_slot_1' , 'discharge_slot_2' ): return self . get ( f ' { key } _start' ), self . get ( f ' { key } _end' ) if key == \"inverter_firmware_version\" : return f 'D0. { self . get ( \"dsp_firmware_version\" ) } -A0. { self . get ( \"arm_firmware_version\" ) } ' # if key == 'modbus_version': # return f'{self.get(\"modbus_version\"):0.2f}' return getattr ( self . _obj , key , default )","title":"get()"},{"location":"api/#givenergy_modbus.model.battery","text":"","title":"battery"},{"location":"api/#givenergy_modbus.model.battery.Battery","text":"Structured format for all inverter attributes.","title":"Battery"},{"location":"api/#givenergy_modbus.model.inverter","text":"","title":"inverter"},{"location":"api/#givenergy_modbus.model.inverter.Inverter","text":"Structured format for all inverter attributes.","title":"Inverter"},{"location":"api/#givenergy_modbus.model.inverter.Inverter.compute_firmware_version","text":"Virtual method to inject a firmware version similar to what the dashboard shows. Source code in givenergy_modbus/model/inverter.py @root_validator def compute_firmware_version ( cls , values ) -> dict : \"\"\"Virtual method to inject a firmware version similar to what the dashboard shows.\"\"\" values [ 'firmware_version' ] = f 'D0. { values [ \"dsp_firmware_version\" ] } -A0. { values [ \"arm_firmware_version\" ] } ' return values","title":"compute_firmware_version()"},{"location":"api/#givenergy_modbus.model.inverter.Inverter.compute_model","text":"Computes the inverter model from the serial number prefix. Source code in givenergy_modbus/model/inverter.py @root_validator def compute_model ( cls , values ) -> dict : \"\"\"Computes the inverter model from the serial number prefix.\"\"\" values [ 'inverter_model' ] = Model ( values [ 'inverter_serial_number' ][: 2 ]) return values","title":"compute_model()"},{"location":"api/#givenergy_modbus.model.inverter.Model","text":"Known models of inverters.","title":"Model"},{"location":"api/#givenergy_modbus.model.plant","text":"","title":"plant"},{"location":"api/#givenergy_modbus.model.plant.Plant","text":"Representation of a complete GivEnergy plant.","title":"Plant"},{"location":"api/#givenergy_modbus.model.register","text":"","title":"register"},{"location":"api/#givenergy_modbus.model.register.HoldingRegister","text":"Holding Register definitions.","title":"HoldingRegister"},{"location":"api/#givenergy_modbus.model.register.InputRegister","text":"Definitions of what registers in the Input Bank represent.","title":"InputRegister"},{"location":"api/#givenergy_modbus.model.register.Register","text":"Mixin to help easier access to register bank structures.","title":"Register"},{"location":"api/#givenergy_modbus.model.register.Scaling","text":"What scaling factor needs to be applied to a register's value. Specified as a divisor instead, because python deals with rounding precision better that way.","title":"Scaling"},{"location":"api/#givenergy_modbus.model.register.Type","text":"Type of data register represents. Encoding is always big-endian.","title":"Type"},{"location":"api/#givenergy_modbus.model.register.Unit","text":"Measurement unit for the register value.","title":"Unit"},{"location":"api/#givenergy_modbus.model.register_cache","text":"","title":"register_cache"},{"location":"api/#givenergy_modbus.model.register_cache.RegisterCache","text":"Holds a cache of Registers populated after querying a device.","title":"RegisterCache"},{"location":"api/#givenergy_modbus.model.register_cache.RegisterCache.__getattr__","text":"Magic attributes that try to look up and convert register values. Source code in givenergy_modbus/model/register_cache.py def __getattr__ ( self , item : str ): \"\"\"Magic attributes that try to look up and convert register values.\"\"\" item_upper = item . upper () if item_upper in self . _register_lookup_table : register = self . _register_lookup_table [ item_upper ] val = self . _registers [ register ] return register . convert ( val ) elif item_upper + '_H' in self . _register_lookup_table and item_upper + '_L' in self . _register_lookup_table : register_h = self . _register_lookup_table [ item_upper + '_H' ] register_l = self . _register_lookup_table [ item_upper + '_L' ] val_h = self . _registers [ register_h ] << 16 val_l = self . _registers [ register_l ] return register_l . convert ( val_h + val_l ) raise KeyError ( item )","title":"__getattr__()"},{"location":"api/#givenergy_modbus.model.register_cache.RegisterCache.debug","text":"Dump the internal state of registers and their value representations. Source code in givenergy_modbus/model/register_cache.py def debug ( self ): \"\"\"Dump the internal state of registers and their value representations.\"\"\" class_name = '' for r , v in self . _registers . items (): if class_name != r . __class__ . __name__ : class_name = r . __class__ . __name__ print ( '### ' + class_name + ' ' + '#' * 100 ) print ( f ' { r } { r . name : >35 } : { r . repr ( v ) : 20 } | ' f ' { r . type . name : 15 } { r . scaling . name : 5 } 0x { v : 04x } { v : 10 } ' )","title":"debug()"},{"location":"api/#givenergy_modbus.model.register_cache.RegisterCache.from_json","text":"Instantiate a RegisterCache from its JSON form. Source code in givenergy_modbus/model/register_cache.py @classmethod def from_json ( cls , data : str ) -> RegisterCache : \"\"\"Instantiate a RegisterCache from its JSON form.\"\"\" def register_object_hook ( object_dict : dict [ str , int ]) -> dict [ Register , int ]: \"\"\"Rewrite the parsed object to have Register instances as keys instead of their (string) repr.\"\"\" lookup = { 'HR' : HoldingRegister , 'IR' : InputRegister } ret = {} for k , v in object_dict . items (): reg , idx = k . split ( ':' , maxsplit = 1 ) ret [ lookup [ reg ]( int ( idx ))] = v return ret return cls ( registers = json . loads ( data , object_hook = register_object_hook ))","title":"from_json()"},{"location":"api/#givenergy_modbus.model.register_cache.RegisterCache.set_registers","text":"Update internal holding register cache with given values. Source code in givenergy_modbus/model/register_cache.py def set_registers ( self , type_ : type [ Register ], registers : dict [ int , int ]): \"\"\"Update internal holding register cache with given values.\"\"\" for k , v in registers . items (): self . _registers [ type_ ( k )] = v","title":"set_registers()"},{"location":"api/#givenergy_modbus.model.register_cache.RegisterCache.to_json","text":"Return JSON representation of the register cache, suitable for using with from_json() . Source code in givenergy_modbus/model/register_cache.py def to_json ( self ) -> str : \"\"\"Return JSON representation of the register cache, suitable for using with `from_json()`.\"\"\" return json . dumps ( self . _registers )","title":"to_json()"},{"location":"api/#givenergy_modbus.model.register_getter","text":"","title":"register_getter"},{"location":"api/#givenergy_modbus.model.register_getter.RegisterGetter","text":"GetterDict implementation to consolidate register data structures.","title":"RegisterGetter"},{"location":"api/#givenergy_modbus.model.register_getter.RegisterGetter.get","text":"Getter that computes some virtual attributes. Source code in givenergy_modbus/model/register_getter.py def get ( self , key : Any , default : Any = None ) -> Any : \"\"\"Getter that computes some virtual attributes.\"\"\" if key == \"inverter_serial_number\" : return '' . join ( [ self . get ( 'inverter_serial_number_1_2' ), self . get ( 'inverter_serial_number_3_4' ), self . get ( 'inverter_serial_number_5_6' ), self . get ( 'inverter_serial_number_7_8' ), self . get ( 'inverter_serial_number_9_10' ), ] ) if key in [ \"num_mppt\" , 'num_phases' ]: obj = self . get ( 'num_mppt_and_num_phases' ) if obj == default : return default elif key == \"num_mppt\" : return obj [ 0 ] return obj [ 1 ] if key == \"battery_serial_number\" : return '' . join ( [ self . get ( 'battery_serial_number_1_2' ), self . get ( 'battery_serial_number_3_4' ), self . get ( 'battery_serial_number_5_6' ), self . get ( 'battery_serial_number_7_8' ), self . get ( 'battery_serial_number_9_10' ), ] ) if key == \"first_battery_serial_number\" : return '' . join ( [ self . get ( 'first_battery_serial_number_1_2' ), self . get ( 'first_battery_serial_number_3_4' ), self . get ( 'first_battery_serial_number_5_6' ), self . get ( 'first_battery_serial_number_7_8' ), self . get ( 'first_battery_serial_number_9_10' ), ] ) # Some special cases first if key == \"system_time\" : return datetime ( self . get ( 'system_time_year' ) + 2000 , self . get ( 'system_time_month' ), self . get ( 'system_time_day' ), self . get ( 'system_time_hour' ), self . get ( 'system_time_minute' ), self . get ( 'system_time_second' ), ) if key in ( 'charge_slot_1' , 'charge_slot_2' , 'discharge_slot_1' , 'discharge_slot_2' ): return self . get ( f ' { key } _start' ), self . get ( f ' { key } _end' ) if key == \"inverter_firmware_version\" : return f 'D0. { self . get ( \"dsp_firmware_version\" ) } -A0. { self . get ( \"arm_firmware_version\" ) } ' # if key == 'modbus_version': # return f'{self.get(\"modbus_version\"):0.2f}' return getattr ( self . _obj , key , default )","title":"get()"},{"location":"api/#givenergy_modbus.pdu","text":"pymodbus.pdu.ModbusPDU implementations for GivEnergy-specific PDU messages.","title":"pdu"},{"location":"api/#givenergy_modbus.pdu.ErrorResponse","text":"Special case PDU that gets returned under some error conditions.","title":"ErrorResponse"},{"location":"api/#givenergy_modbus.pdu.ErrorResponse.decode","text":"Decode response PDU message and populate instance attributes. Source code in givenergy_modbus/pdu.py def decode ( self , data : bytes ): \"\"\"Decode response PDU message and populate instance attributes.\"\"\" decoder = BinaryPayloadDecoder ( data , byteorder = Endian . Big ) self . data_adapter_serial_number = decoder . decode_string ( 10 ) . decode ( \"ascii\" ) self . error_code = decoder . decode_8bit_uint () _logger . debug ( f \"Successfully decoded { len ( data ) } bytes\" )","title":"decode()"},{"location":"api/#givenergy_modbus.pdu.ErrorResponse.encode","text":"Encode request PDU message and populate instance attributes. Source code in givenergy_modbus/pdu.py def encode ( self ) -> bytes : \"\"\"Encode request PDU message and populate instance attributes.\"\"\" self . builder = BinaryPayloadBuilder ( byteorder = Endian . Big ) self . builder . add_string ( f \" { self . data_adapter_serial_number [ - 10 :] : *>10 } \" ) # ensure exactly 10 bytes self . builder . add_8bit_uint ( self . error_code ) return self . builder . to_string ()","title":"encode()"},{"location":"api/#givenergy_modbus.pdu.ErrorResponse.get_response_pdu_size","text":"Predict the size of the response PDU. Source code in givenergy_modbus/pdu.py @staticmethod def get_response_pdu_size () -> int : \"\"\"Predict the size of the response PDU.\"\"\" return 11","title":"get_response_pdu_size()"},{"location":"api/#givenergy_modbus.pdu.ModbusPDU","text":"Base of the PDU handler tree. Defines the most common shared attributes and code.","title":"ModbusPDU"},{"location":"api/#givenergy_modbus.pdu.ModbusPDU.decode","text":"Decode PDU message and populate instance attributes. Source code in givenergy_modbus/pdu.py def decode ( self , data : bytes ) -> None : \"\"\"Decode PDU message and populate instance attributes.\"\"\" decoder = BinaryPayloadDecoder ( data , byteorder = Endian . Big ) self . data_adapter_serial_number = decoder . decode_string ( 10 ) . decode ( \"ascii\" ) self . padding = decoder . decode_64bit_uint () self . slave_address = decoder . decode_8bit_uint () function_code = decoder . decode_8bit_uint () if function_code >= 0x80 : self . error = True function_code = function_code & 0x7F if self . function_code != function_code : e = ValueError ( f \"Expected function code 0x { self . function_code : 02x } , found 0x { function_code : 02x } instead.\" , self ) _logger . exception ( e ) raise e self . _decode_function_data ( decoder ) self . _ensure_valid_state () _logger . debug ( f \"Successfully decoded { len ( data ) } bytes\" )","title":"decode()"},{"location":"api/#givenergy_modbus.pdu.ModbusPDU.encode","text":"Encode PDU message from instance attributes. Source code in givenergy_modbus/pdu.py def encode ( self ) -> bytes : \"\"\"Encode PDU message from instance attributes.\"\"\" self . _ensure_valid_state () self . builder = BinaryPayloadBuilder ( byteorder = Endian . Big ) self . builder . add_string ( f \" { self . data_adapter_serial_number [ - 10 :] : *>10 } \" ) # ensure exactly 10 bytes self . builder . add_64bit_uint ( self . padding ) self . builder . add_8bit_uint ( self . slave_address ) self . builder . add_8bit_uint ( self . function_code ) self . _encode_function_data () self . _update_check_code () return self . builder . to_string ()","title":"encode()"},{"location":"api/#givenergy_modbus.pdu.ModbusPDU.execute","text":"Called to create the Response PDU after an incoming message has been completely processed. Source code in givenergy_modbus/pdu.py def execute ( self , context : IModbusSlaveContext ) -> ModbusPDU : \"\"\"Called to create the Response PDU after an incoming message has been completely processed.\"\"\" raise NotImplementedError ()","title":"execute()"},{"location":"api/#givenergy_modbus.pdu.ModbusPDU.get_response_pdu_size","text":"Allows the framer to decapsulate the PDU properly from the MBAP frame header. Source code in givenergy_modbus/pdu.py def get_response_pdu_size ( self ) -> int : \"\"\"Allows the framer to decapsulate the PDU properly from the MBAP frame header.\"\"\" # 20 = 10 (data adapter serial) + 8 (padding) + 1 (slave addr) + 1 (function code) size = 20 + self . _calculate_function_data_size () _logger . debug ( f \"Calculated { size } bytes total response PDU size for { self } \" ) if size >= 247 : _logger . error ( 'Expected response size {size} b exceeds Modbus protocol spec' ) return size","title":"get_response_pdu_size()"},{"location":"api/#givenergy_modbus.pdu.ModbusRequest","text":"Root of the hierarchy for Request PDUs.","title":"ModbusRequest"},{"location":"api/#givenergy_modbus.pdu.ModbusRequest.execute","text":"Hook that allows a Response PDU to be created from the same context where the Request was handled. Parameters: Name Type Description Default context IModbusSlaveContext A datastore context that should be able to provide the values to populate the Response with. required Source code in givenergy_modbus/pdu.py def execute ( self , context : IModbusSlaveContext ) -> ModbusResponse : \"\"\"Hook that allows a Response PDU to be created from the same context where the Request was handled. Args: context: A datastore context that should be able to provide the values to populate the Response with. \"\"\" # if not (1 <= self.register_count <= 0x7D0): # return self.doException(ModbusExceptions.IllegalValue) # if not context.validate(self.function_code, self.base_register, self.register_count): # return self.doException(ModbusExceptions.IllegalAddress) # values = context.getValues(self.function_code, self.address, self.count) # return ReadRegistersResponse(values) # echo back some values from the Request in the Response raise NotImplementedError ()","title":"execute()"},{"location":"api/#givenergy_modbus.pdu.ModbusResponse","text":"Root of the hierarchy for Response PDUs.","title":"ModbusResponse"},{"location":"api/#givenergy_modbus.pdu.ModbusResponse.execute","text":"There is no automatic Reply following the processing of a Response. Source code in givenergy_modbus/pdu.py def execute ( self , context ) -> ModbusPDU : \"\"\"There is no automatic Reply following the processing of a Response.\"\"\"","title":"execute()"},{"location":"api/#givenergy_modbus.pdu.ReadHoldingRegistersMeta","text":"Request & Response PDUs for function #3/Read Holding Registers.","title":"ReadHoldingRegistersMeta"},{"location":"api/#givenergy_modbus.pdu.ReadHoldingRegistersRequest","text":"Concrete PDU implementation for handling function #3/Read Holding Registers request messages.","title":"ReadHoldingRegistersRequest"},{"location":"api/#givenergy_modbus.pdu.ReadHoldingRegistersRequest.execute","text":"FIXME if we ever implement a server. Source code in givenergy_modbus/pdu.py def execute ( self , context ) -> ModbusResponse : \"\"\"FIXME if we ever implement a server.\"\"\" raise NotImplementedError ()","title":"execute()"},{"location":"api/#givenergy_modbus.pdu.ReadHoldingRegistersResponse","text":"Concrete PDU implementation for handling function #3/Read Holding Registers response messages.","title":"ReadHoldingRegistersResponse"},{"location":"api/#givenergy_modbus.pdu.ReadInputRegistersMeta","text":"Request & Response PDUs for function #4/Read Input Registers.","title":"ReadInputRegistersMeta"},{"location":"api/#givenergy_modbus.pdu.ReadInputRegistersRequest","text":"Concrete PDU implementation for handling function #4/Read Input Registers request messages.","title":"ReadInputRegistersRequest"},{"location":"api/#givenergy_modbus.pdu.ReadInputRegistersRequest.execute","text":"FIXME if we ever implement a server. Source code in givenergy_modbus/pdu.py def execute ( self , context ) -> ModbusResponse : \"\"\"FIXME if we ever implement a server.\"\"\" raise NotImplementedError ()","title":"execute()"},{"location":"api/#givenergy_modbus.pdu.ReadInputRegistersResponse","text":"Concrete PDU implementation for handling function #4/Read Input Registers response messages.","title":"ReadInputRegistersResponse"},{"location":"api/#givenergy_modbus.pdu.ReadRegistersRequest","text":"Handles all messages that request a range of registers.","title":"ReadRegistersRequest"},{"location":"api/#givenergy_modbus.pdu.ReadRegistersRequest.__init__","text":"Proxy to the lower level initializer Source code in givenergy_modbus/pdu.py def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) self . base_register = kwargs . get ( 'base_register' , 0x0000 ) self . register_count = kwargs . get ( 'register_count' , 0x0000 )","title":"__init__()"},{"location":"api/#givenergy_modbus.pdu.ReadRegistersResponse","text":"Handles all messages that respond with a range of registers.","title":"ReadRegistersResponse"},{"location":"api/#givenergy_modbus.pdu.ReadRegistersResponse.__init__","text":"Proxy to the lower level initializer Source code in givenergy_modbus/pdu.py def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) self . inverter_serial_number : str = kwargs . get ( 'inverter_serial_number' , 'SA1234G567' ) self . base_register : int = kwargs . get ( 'base_register' , 0x0000 ) self . register_count : int = kwargs . get ( 'register_count' , 0x0000 ) self . register_values : list [ int ] = kwargs . get ( 'register_values' , []) if self . register_count != len ( self . register_values ): raise ValueError ( f 'Expected to receive { self . register_count } register values, ' f 'instead received { len ( self . register_values ) } .' , self , ) # self.check: int = kwargs.get('check', 0x0000)","title":"__init__()"},{"location":"api/#givenergy_modbus.pdu.ReadRegistersResponse.to_dict","text":"Return the registers as a dict of register_index:value. Accounts for base_register offsets. Source code in givenergy_modbus/pdu.py def to_dict ( self ): \"\"\"Return the registers as a dict of register_index:value. Accounts for base_register offsets.\"\"\" return { k : v for k , v in enumerate ( self . register_values , start = self . base_register )}","title":"to_dict()"},{"location":"api/#givenergy_modbus.pdu.WriteHoldingRegisterMeta","text":"Request & Response PDUs for function #6/Write Holding Register.","title":"WriteHoldingRegisterMeta"},{"location":"api/#givenergy_modbus.pdu.WriteHoldingRegisterRequest","text":"Concrete PDU implementation for handling function #6/Write Holding Register request messages.","title":"WriteHoldingRegisterRequest"},{"location":"api/#givenergy_modbus.pdu.WriteHoldingRegisterResponse","text":"Concrete PDU implementation for handling function #6/Write Holding Register response messages.","title":"WriteHoldingRegisterResponse"},{"location":"api/#givenergy_modbus.transaction","text":"","title":"transaction"},{"location":"api/#givenergy_modbus.transaction.GivEnergyTransactionManager","text":"Implements a ModbusTransactionManager. The only reason this exists is to be able to specify the ADU size for automated response frame processing since the socket needs to know how many bytes to expect in response to a given Request. See ModbusTransactionManager::execute where it checks whether the framer is an instance of ModbusSocketFramer to inform the expected response length, and even lower down the call chain in ModbusTransactionManager::_recv where there's more byte calculations based on the TransactionManager's provenance. We could've extended GivEnergyModbusFramer from ModbusSocketFramer instead, but that brings a different set of problems around implementation divergence in the GivEnergy implementation that would probably have been more work instead. Full novel in the GivEnergyModbusFramer class description.","title":"GivEnergyTransactionManager"},{"location":"api/#givenergy_modbus.transaction.GivEnergyTransactionManager.execute","text":"Main processing loop. Source code in givenergy_modbus/transaction.py def execute ( self , request : ModbusPDU ) -> ModbusPDU : \"\"\"Main processing loop.\"\"\" res = super () . execute ( request ) _logger . debug ( f 'Old implementation returned: execute(request)= { res } ' ) return res","title":"execute()"},{"location":"api/#givenergy_modbus.util","text":"","title":"util"},{"location":"api/#givenergy_modbus.util.InterceptHandler","text":"Install loguru by intercepting logging.","title":"InterceptHandler"},{"location":"api/#givenergy_modbus.util.InterceptHandler.emit","text":"Redirect logging emissions to loguru instead. Source code in givenergy_modbus/util.py def emit ( self , record ): \"\"\"Redirect logging emissions to loguru instead.\"\"\" # Get corresponding Loguru level if it exists try : level = logger . level ( record . levelname ) . name except ValueError : level = record . levelno # Find caller from where originated the logged message frame , depth = logging . currentframe (), 2 while frame . f_code . co_filename == logging . __file__ : frame = frame . f_back depth += 1 logger . opt ( depth = depth , exception = record . exc_info ) . log ( level , record . getMessage ())","title":"emit()"},{"location":"api/#givenergy_modbus.util.friendly_class_name","text":"Provides an easy way to only show the class name. Source code in givenergy_modbus/util.py def friendly_class_name ( c : Any ): \"\"\"Provides an easy way to only show the class name.\"\"\" if inspect . isclass ( c ): return str ( c )[ 8 : - 2 ] . rsplit ( \".\" , maxsplit = 1 )[ - 1 ] return friendly_class_name ( c . __class__ ) # + f'({vars(c)})'","title":"friendly_class_name()"},{"location":"api/#givenergy_modbus.util.hexlify","text":"Provides an easy way to print long byte strings as hex strings. Source code in givenergy_modbus/util.py def hexlify ( val ) -> str : \"\"\"Provides an easy way to print long byte strings as hex strings.\"\"\" if isinstance ( val , int ): val = val . to_bytes (( val . bit_length () + 8 ) // 8 , 'big' ) if isinstance ( val , bytes ): if sys . version_info < ( 3 , 8 ): # TODO remove once 3.7 is unsupported return binascii . hexlify ( val ) . decode ( 'ascii' ) return binascii . hexlify ( val , sep = ' ' , bytes_per_sep = 2 ) . decode ( 'ascii' ) return str ( val )","title":"hexlify()"},{"location":"api/#givenergy_modbus.util.hexxed","text":"Provides an easy way to print hex values when you might not always have ints. Source code in givenergy_modbus/util.py def hexxed ( val ): \"\"\"Provides an easy way to print hex values when you might not always have ints.\"\"\" if isinstance ( val , ( int , bytes )): return f '0x { val : 04x } ' return val","title":"hexxed()"},{"location":"changelog/","text":"Changelog \u00b6 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . Unreleased \u00b6 0.9.3 - 2022-02-01 \u00b6 Fixed \u00b6 \ud83e\uddfd Update total energy registers (by @britkat1980) \ud83d\udee0 Re-enable builds back to python v3.7 to support e.g. Raspberry Pi current version \ud83e\uddf9 Update python and pre-commit deps, including security fix for loguru 0.9.2 - 2022-01-24 \u00b6 Fixed \u00b6 \ud83d\udc1b Scaled registers to use division instead of multiplication \u2013 prevents rounding errors. \ud83d\udcd6 Update README.md to match reality better \ud83e\uddfd Update deps \ud83d\udee0 Try to re-enable GH pages 0.9.1 - 2022-01-13 \u00b6 Fixed \u00b6 \ud83d\udc1b The _time fault registers don't denote a BCD-encoded timestamp, but seems to be a counter of #cycles the fault lasted. Sometimes a time slot timestamp is returned as 60 minutes. Guard by taking the modulo-60 instead. 0.9.0 - 2022-01-13 \u00b6 Added \u00b6 \ud83d\udcaa Create RegisterCache and RegisterGetter to contain the custom register data structures in one place. Also started a Plant model to be a container for all devices in a given system. \ud83d\udee0 Add JSON processing for the RegisterCache \u2013 mostly to help with testing but also expecting debugging other plants to benefit from it. \ud83d\udc77 Add some more test cases with actual register data. \ud83d\udea8 Added some recovery logic to the framer \u2013 try to scan ahead for other messages instead of truncating the entire buffer when there's unexpected data incoming. Hopefully this helps when the communication stream seems to get out of sync a bit. \ud83d\ude45 Add an ErrorResponse PDU so we can try and cope better when the inverter throws error responses. \ud83e\uddfd Added absolufy-imports and autoflake to pre-commit checks. Changed \u00b6 \u26a0\ufe0f Ensure we check charge and discharge limits: current hardware cannot support >50% (i.e. >2.6kW) rates. \u2705 Make sure we query the 180+ block of input registers too, since it contains (amongst others) battery energy counters. \ud83e\udd14 Split out querying the battery/BMS registers since this will vary depending on how many batteries the user has. The slave address of the request determines which battery unit is targeted. Also start modeling the Battery as separate from the Inverter. \ud83d\udd0e Collapse the register cache to a single dict since we can use the HoldingRegister / InputRegister identity to discern between the types. It makes the data structures a lot simpler. \ud83d\udee0 Improve the CLI \u2013 it is already a useful tool to dump registers for debugging right now. \ud83d\ude33 Changed to target slave id 0x11 by default instead of 0x32. 0x32 shadows 0x11 but seems to be the first battery, with subsequent batteries living at the following slave addresses. \u261d\ufe0f reverted that change because it seems to affect the cloud metrics quite badly when you query frequently. \ud83e\udd2b Squelch flake8 warnings about missing constructor and magic method docstrings. \ud83e\ude79 Update README to show usage properly. \ud83e\uddf9 Update python deps. 0.8.0 - 2022-01-09 \u00b6 Added \u00b6 A large number of convenience methods in the client to alter the state of the inverter: enable_charge_target(target_soc: int) & disable_charge_target() enable_charge() & disable_charge() enable_discharge() and enable_discharge() set_battery_discharge_mode_max_power() and set_battery_discharge_mode_demand() set_charge_slot_n((start_time: datetime.time, end_time: datetime.time)) and reset_charge_slot_n() for slots 1 & 2. Also matching set_discharge_slot_n((start_time, end_time)) and reset_discharge_slot_n() . set_mode_dynamic() to maximise storage of generation and discharge during demand. This mirrors \"mode 1\" operation in the portal. set_mode_storage(slot_1, [slot_2], [export]) which keeps the battery charge topped-up and discharges during specified periods. This mirrors modes 2-4 in the portal. set_datetime(datetime) to set the inverter date & time. Ensure we always close the network socket after every request. Sometimes the inverter turns orange/grey in the portal after executing queries via this library, and this seems to mitigate against it \u2013 possible the inverter TCP stack isn't closing half-closed sockets aggressively enough? Changed \u00b6 Potentially breaking: Once again, pretty wholesale renaming of registers to more official designations, and standardising naming somewhat. Part of the motivation for adding more convenience functions is so clients never have to deal with register names directly, so this should hopefully make future renaming easier. 0.7.0 - 2022-01-05 \u00b6 Added \u00b6 Another register whitelist and check in the WriteHoldingRegisterRequest PDU as another layer of checks to not inadvertently write to unsafe registers. Add a test to ensure the allow list stays in sync with the register definitions from model.register_banks.HoldingRegister . A bunch of convenience methods to write data to the inverter without needing any knowledge of registers. See client.GivEnergyClient which has a number of set_* methods. Changed \u00b6 Split out the end-user client functionality from the Modbus client - they were getting too entangled unnecessarily. Updated example code in README for reference. Renamed target_soc to battery_target_soc instead. 0.6.2 - 2022-01-04 \u00b6 Fixed \u00b6 Will this fix mindsers/changelog-reader-action@v2 ? 0.6.1 - 2022-01-04 \u00b6 Fixed \u00b6 Fix stupid pypi classifier strictness 0.6.0 - 2022-01-04 \u00b6 Changed \u00b6 [BREAKING CHANGE] registers have been widely renamed for consistency and clarity. The joys of a pre-release API. Checked all the registers and their values to make sense. Added units for most that are self-evident. The Inverter object is shaping up nicely as a user-friendly representation of the inverter dataset \u2013 TODO is likely splitting out a Battery representation too, to account for systems with multiple battery units (and those without batteries at all!). The same might make sense for the PV aspect as well. Fixed \u00b6 Avoid loading a whole batch of input registers that seem completely unused and save a network call. Match prod release workflow to preview to use py3.9 Update PyPI classifiers to specify Alpha quality :) 0.5.0 (2022-01-04) \u00b6 Simplify the client contract so you only work with structured data instead of register banks. Add example use to README 0.4.0 (2022-01-03) \u00b6 Implement writing values to single holding registers 0.3.0 (2022-01-03) \u00b6 Make register definitions a bit more flexible to cater for units and descriptions in future 0.2.0 (2022-01-03) \u00b6 Fix GitHub actions & codecov 0.1.1 (2022-01-02) \u00b6 Update deps Rename a few class names for consistency Add a few more attributes to export 0.1.0 (2022-01-02) \u00b6 First release on PyPI","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"Unreleased"},{"location":"changelog/#093---2022-02-01","text":"","title":"0.9.3 - 2022-02-01"},{"location":"changelog/#fixed","text":"\ud83e\uddfd Update total energy registers (by @britkat1980) \ud83d\udee0 Re-enable builds back to python v3.7 to support e.g. Raspberry Pi current version \ud83e\uddf9 Update python and pre-commit deps, including security fix for loguru","title":"Fixed"},{"location":"changelog/#092---2022-01-24","text":"","title":"0.9.2 - 2022-01-24"},{"location":"changelog/#fixed_1","text":"\ud83d\udc1b Scaled registers to use division instead of multiplication \u2013 prevents rounding errors. \ud83d\udcd6 Update README.md to match reality better \ud83e\uddfd Update deps \ud83d\udee0 Try to re-enable GH pages","title":"Fixed"},{"location":"changelog/#091---2022-01-13","text":"","title":"0.9.1 - 2022-01-13"},{"location":"changelog/#fixed_2","text":"\ud83d\udc1b The _time fault registers don't denote a BCD-encoded timestamp, but seems to be a counter of #cycles the fault lasted. Sometimes a time slot timestamp is returned as 60 minutes. Guard by taking the modulo-60 instead.","title":"Fixed"},{"location":"changelog/#090---2022-01-13","text":"","title":"0.9.0 - 2022-01-13"},{"location":"changelog/#added","text":"\ud83d\udcaa Create RegisterCache and RegisterGetter to contain the custom register data structures in one place. Also started a Plant model to be a container for all devices in a given system. \ud83d\udee0 Add JSON processing for the RegisterCache \u2013 mostly to help with testing but also expecting debugging other plants to benefit from it. \ud83d\udc77 Add some more test cases with actual register data. \ud83d\udea8 Added some recovery logic to the framer \u2013 try to scan ahead for other messages instead of truncating the entire buffer when there's unexpected data incoming. Hopefully this helps when the communication stream seems to get out of sync a bit. \ud83d\ude45 Add an ErrorResponse PDU so we can try and cope better when the inverter throws error responses. \ud83e\uddfd Added absolufy-imports and autoflake to pre-commit checks.","title":"Added"},{"location":"changelog/#changed","text":"\u26a0\ufe0f Ensure we check charge and discharge limits: current hardware cannot support >50% (i.e. >2.6kW) rates. \u2705 Make sure we query the 180+ block of input registers too, since it contains (amongst others) battery energy counters. \ud83e\udd14 Split out querying the battery/BMS registers since this will vary depending on how many batteries the user has. The slave address of the request determines which battery unit is targeted. Also start modeling the Battery as separate from the Inverter. \ud83d\udd0e Collapse the register cache to a single dict since we can use the HoldingRegister / InputRegister identity to discern between the types. It makes the data structures a lot simpler. \ud83d\udee0 Improve the CLI \u2013 it is already a useful tool to dump registers for debugging right now. \ud83d\ude33 Changed to target slave id 0x11 by default instead of 0x32. 0x32 shadows 0x11 but seems to be the first battery, with subsequent batteries living at the following slave addresses. \u261d\ufe0f reverted that change because it seems to affect the cloud metrics quite badly when you query frequently. \ud83e\udd2b Squelch flake8 warnings about missing constructor and magic method docstrings. \ud83e\ude79 Update README to show usage properly. \ud83e\uddf9 Update python deps.","title":"Changed"},{"location":"changelog/#080---2022-01-09","text":"","title":"0.8.0 - 2022-01-09"},{"location":"changelog/#added_1","text":"A large number of convenience methods in the client to alter the state of the inverter: enable_charge_target(target_soc: int) & disable_charge_target() enable_charge() & disable_charge() enable_discharge() and enable_discharge() set_battery_discharge_mode_max_power() and set_battery_discharge_mode_demand() set_charge_slot_n((start_time: datetime.time, end_time: datetime.time)) and reset_charge_slot_n() for slots 1 & 2. Also matching set_discharge_slot_n((start_time, end_time)) and reset_discharge_slot_n() . set_mode_dynamic() to maximise storage of generation and discharge during demand. This mirrors \"mode 1\" operation in the portal. set_mode_storage(slot_1, [slot_2], [export]) which keeps the battery charge topped-up and discharges during specified periods. This mirrors modes 2-4 in the portal. set_datetime(datetime) to set the inverter date & time. Ensure we always close the network socket after every request. Sometimes the inverter turns orange/grey in the portal after executing queries via this library, and this seems to mitigate against it \u2013 possible the inverter TCP stack isn't closing half-closed sockets aggressively enough?","title":"Added"},{"location":"changelog/#changed_1","text":"Potentially breaking: Once again, pretty wholesale renaming of registers to more official designations, and standardising naming somewhat. Part of the motivation for adding more convenience functions is so clients never have to deal with register names directly, so this should hopefully make future renaming easier.","title":"Changed"},{"location":"changelog/#070---2022-01-05","text":"","title":"0.7.0 - 2022-01-05"},{"location":"changelog/#added_2","text":"Another register whitelist and check in the WriteHoldingRegisterRequest PDU as another layer of checks to not inadvertently write to unsafe registers. Add a test to ensure the allow list stays in sync with the register definitions from model.register_banks.HoldingRegister . A bunch of convenience methods to write data to the inverter without needing any knowledge of registers. See client.GivEnergyClient which has a number of set_* methods.","title":"Added"},{"location":"changelog/#changed_2","text":"Split out the end-user client functionality from the Modbus client - they were getting too entangled unnecessarily. Updated example code in README for reference. Renamed target_soc to battery_target_soc instead.","title":"Changed"},{"location":"changelog/#062---2022-01-04","text":"","title":"0.6.2 - 2022-01-04"},{"location":"changelog/#fixed_3","text":"Will this fix mindsers/changelog-reader-action@v2 ?","title":"Fixed"},{"location":"changelog/#061---2022-01-04","text":"","title":"0.6.1 - 2022-01-04"},{"location":"changelog/#fixed_4","text":"Fix stupid pypi classifier strictness","title":"Fixed"},{"location":"changelog/#060---2022-01-04","text":"","title":"0.6.0 - 2022-01-04"},{"location":"changelog/#changed_3","text":"[BREAKING CHANGE] registers have been widely renamed for consistency and clarity. The joys of a pre-release API. Checked all the registers and their values to make sense. Added units for most that are self-evident. The Inverter object is shaping up nicely as a user-friendly representation of the inverter dataset \u2013 TODO is likely splitting out a Battery representation too, to account for systems with multiple battery units (and those without batteries at all!). The same might make sense for the PV aspect as well.","title":"Changed"},{"location":"changelog/#fixed_5","text":"Avoid loading a whole batch of input registers that seem completely unused and save a network call. Match prod release workflow to preview to use py3.9 Update PyPI classifiers to specify Alpha quality :)","title":"Fixed"},{"location":"changelog/#050-2022-01-04","text":"Simplify the client contract so you only work with structured data instead of register banks. Add example use to README","title":"0.5.0 (2022-01-04)"},{"location":"changelog/#040-2022-01-03","text":"Implement writing values to single holding registers","title":"0.4.0 (2022-01-03)"},{"location":"changelog/#030-2022-01-03","text":"Make register definitions a bit more flexible to cater for units and descriptions in future","title":"0.3.0 (2022-01-03)"},{"location":"changelog/#020-2022-01-03","text":"Fix GitHub actions & codecov","title":"0.2.0 (2022-01-03)"},{"location":"changelog/#011-2022-01-02","text":"Update deps Rename a few class names for consistency Add a few more attributes to export","title":"0.1.1 (2022-01-02)"},{"location":"changelog/#010-2022-01-02","text":"First release on PyPI","title":"0.1.0 (2022-01-02)"},{"location":"contributing/","text":"Contributing \u00b6 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions \u00b6 Report Bugs \u00b6 Report bugs at https://github.com/dewet22/givenergy-modbus/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs \u00b6 Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features \u00b6 Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation \u00b6 GivEnergy Modbus could always use more documentation, whether as part of the official GivEnergy Modbus docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback \u00b6 The best way to send feedback is to file an issue at https://github.com/dewet22/givenergy-modbus/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Get Started! \u00b6 Ready to contribute? Here's how to set up givenergy-modbus for local development. Fork the givenergy-modbus repo on GitHub. Clone your fork locally $ git clone git@github.com:your_name_here/givenergy-modbus.git Ensure poetry is installed. Install dependencies and start your virtualenv: $ poetry install -E test -E doc -E dev Create a branch for local development: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: $ poetry run tox Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Pull Request Guidelines \u00b6 Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8 and 3.9. Check https://github.com/dewet22/givenergy-modbus/actions and make sure that the tests pass for all supported Python versions. Tips \u00b6 $ poetry run pytest tests/test_givenergy_modbus.py To run a subset of tests. Deploying \u00b6 A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in CHANGELOG.md). Then run: $ poetry run bump2version patch # possible: major / minor / patch $ git push $ git push --tags GitHub Actions will then deploy to PyPI if tests pass.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing/#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"contributing/#report-bugs","text":"Report bugs at https://github.com/dewet22/givenergy-modbus/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"contributing/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"contributing/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"contributing/#write-documentation","text":"GivEnergy Modbus could always use more documentation, whether as part of the official GivEnergy Modbus docs, in docstrings, or even on the web in blog posts, articles, and such.","title":"Write Documentation"},{"location":"contributing/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/dewet22/givenergy-modbus/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"contributing/#get-started","text":"Ready to contribute? Here's how to set up givenergy-modbus for local development. Fork the givenergy-modbus repo on GitHub. Clone your fork locally $ git clone git@github.com:your_name_here/givenergy-modbus.git Ensure poetry is installed. Install dependencies and start your virtualenv: $ poetry install -E test -E doc -E dev Create a branch for local development: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: $ poetry run tox Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started!"},{"location":"contributing/#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8 and 3.9. Check https://github.com/dewet22/givenergy-modbus/actions and make sure that the tests pass for all supported Python versions.","title":"Pull Request Guidelines"},{"location":"contributing/#tips","text":"$ poetry run pytest tests/test_givenergy_modbus.py To run a subset of tests.","title":"Tips"},{"location":"contributing/#deploying","text":"A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in CHANGELOG.md). Then run: $ poetry run bump2version patch # possible: major / minor / patch $ git push $ git push --tags GitHub Actions will then deploy to PyPI if tests pass.","title":"Deploying"},{"location":"installation/","text":"Installation \u00b6 Stable release \u00b6 To install GivEnergy Modbus, run this command in your terminal: $ pip install givenergy-modbus This is the preferred method to install GivEnergy Modbus, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process. From source \u00b6 The source for GivEnergy Modbus can be downloaded from the Github repo . You can either clone the public repository: $ git clone git://github.com/dewet22/givenergy-modbus Or download the tarball : $ curl -OJL https://github.com/dewet22/givenergy-modbus/tarball/master Once you have a copy of the source, you can install it with: $ pip install .","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#stable-release","text":"To install GivEnergy Modbus, run this command in your terminal: $ pip install givenergy-modbus This is the preferred method to install GivEnergy Modbus, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process.","title":"Stable release"},{"location":"installation/#from-source","text":"The source for GivEnergy Modbus can be downloaded from the Github repo . You can either clone the public repository: $ git clone git://github.com/dewet22/givenergy-modbus Or download the tarball : $ curl -OJL https://github.com/dewet22/givenergy-modbus/tarball/master Once you have a copy of the source, you can install it with: $ pip install .","title":"From source"},{"location":"usage/","text":"Usage \u00b6 To use GivEnergy Modbus in a project import givenergy_modbus","title":"Usage"},{"location":"usage/#usage","text":"To use GivEnergy Modbus in a project import givenergy_modbus","title":"Usage"}]}